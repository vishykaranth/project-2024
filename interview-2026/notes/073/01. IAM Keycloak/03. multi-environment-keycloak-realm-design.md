# Multi-Environment Keycloak Realm Design

## Executive Summary

This document outlines the design and implementation plan for supporting **multiple environments per tenant** with **Keycloak realm-per-environment** strategy. Currently, the system uses a **realm-per-tenant** approach, which needs to be extended to support environment-level isolation.

**Current State**: 1 Tenant = 1 Keycloak Realm  
**Target State**: 1 Tenant × N Environments = N Keycloak Realms

---

## 1. Current Design Analysis

### 1.1 Current Architecture

```
┌─────────────────────────────────────────────────────────┐
│         Current Realm Strategy                         │
└─────────────────────────────────────────────────────────┘

Tenant: "jiffy-default"
    │
    └─► Keycloak Realm: "jiffy-default"
            │
            ├─► All Users (dev, staging, prod)
            ├─► All Applications
            └─► All Environments

Problem: Username uniqueness conflicts across environments
```

### 1.2 Current Implementation

**Realm Resolution:**
```java
// Current implementation
RealmResource realmResource = keyCloak.realm(tenant.getTenantName());
```

**Key Files:**
- `UserServiceImpl.java` - Uses `tenant.getTenantName()` for realm
- `LoginServiceForKeyCloakImpl.java` - Uses tenant name for token endpoints
- `KeyCloakClient.java` - Builds client with tenant realm
- `IDPConfig.java` - Stores tenant name as realm name

**Issues:**
1. ❌ No environment context in realm selection
2. ❌ Username conflicts across environments
3. ❌ No environment-level user isolation
4. ❌ Token validation doesn't consider environment

---

## 2. Proposed Design

### 2.1 New Architecture

```
┌─────────────────────────────────────────────────────────┐
│         New Realm Strategy (Realm per Environment)     │
└─────────────────────────────────────────────────────────┘

Tenant: "jiffy-default"
    │
    ├─► Environment: "dev"
    │       └─► Keycloak Realm: "jiffy-default-dev"
    │               ├─► Dev Users
    │               ├─► Dev Applications
    │               └─► Dev Configuration
    │
    ├─► Environment: "staging"
    │       └─► Keycloak Realm: "jiffy-default-staging"
    │               ├─► Staging Users
    │               ├─► Staging Applications
    │               └─► Staging Configuration
    │
    └─► Environment: "prod"
            └─► Keycloak Realm: "jiffy-default-prod"
                    ├─► Prod Users
                    ├─► Prod Applications
                    └─► Prod Configuration

Benefits:
✅ Username uniqueness per environment
✅ Environment-level isolation
✅ Independent configuration per environment
✅ Better security boundaries
```

### 2.2 Realm Naming Strategy

**Pattern**: `{tenantName}-{environmentName}`

**Examples:**
- Tenant: `jiffy-default`, Environment: `dev` → Realm: `jiffy-default-dev`
- Tenant: `jiffy-default`, Environment: `staging` → Realm: `jiffy-default-staging`
- Tenant: `jiffy-default`, Environment: `prod` → Realm: `jiffy-default-prod`

**Validation Rules:**
- Realm name must be unique across all tenants
- Environment name must be valid (alphanumeric, hyphens, underscores)
- Realm name length: Max 63 characters (Keycloak limit)

**Realm Name Builder:**
```java
public String buildRealmName(String tenantName, String environmentName) {
    return String.format("%s-%s", tenantName, environmentName);
}
```

---

## 3. Design Components

### 3.1 Realm Resolution Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Realm Resolution Flow                          │
└─────────────────────────────────────────────────────────┘

Request Context
    │
    ├─► Extract: Tenant
    ├─► Extract: Environment
    │       ├─► From: Request parameter (envName)
    │       ├─► From: Application.environment
    │       ├─► From: AppInstance → Environment mapping
    │       └─► Default: "common" (backward compatibility)
    │
    └─► Build: Realm Name
            └─► {tenantName}-{environmentName}

Realm Selection Priority:
1. Explicit environment parameter
2. Application environment
3. AppInstance environment mapping
4. Default environment (for backward compatibility)
```

### 3.2 Environment Context Propagation

```
┌─────────────────────────────────────────────────────────┐
│         Environment Context Flow                       │
└─────────────────────────────────────────────────────────┘

API Request
    │
    ├─► Headers/Parameters
    │       ├─► X-Tenant-Id: {tenantId}
    │       ├─► X-Environment-Name: {envName} (new)
    │       └─► X-App-Id: {appId}
    │
    ├─► Application Lookup
    │       └─► Application.environment
    │
    ├─► AppInstance Lookup (if appInstanceId provided)
    │       └─► AppInstance → Environment mapping
    │
    └─► Resolve: Environment Context
            └─► Use for realm selection
```

---

## 4. Impact Analysis

### 4.1 Database Schema Changes

#### 4.1.1 New Tables

```sql
-- Environment-Realm Mapping Table
CREATE TABLE environment_realm_mapping (
    id VARCHAR(40) PRIMARY KEY,
    tenant_id VARCHAR(40) NOT NULL,
    environment_id VARCHAR(40) NOT NULL,
    realm_name VARCHAR(100) NOT NULL UNIQUE,
    keycloak_realm_id VARCHAR(100), -- Keycloak's internal realm ID
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenant(tenant_id),
    FOREIGN KEY (environment_id) REFERENCES environment(id),
    UNIQUE(tenant_id, environment_id)
);

-- Indexes
CREATE INDEX idx_env_realm_tenant ON environment_realm_mapping(tenant_id);
CREATE INDEX idx_env_realm_env ON environment_realm_mapping(environment_id);
CREATE INDEX idx_env_realm_name ON environment_realm_mapping(realm_name);
```

#### 4.1.2 Modified Tables

```sql
-- Add environment context to ApexUser
ALTER TABLE apex_user 
ADD COLUMN environment_id VARCHAR(40),
ADD COLUMN primary_environment VARCHAR(50), -- Primary environment for user
ADD COLUMN accessible_environments TEXT[]; -- Array of accessible environments

-- Foreign key
ALTER TABLE apex_user 
ADD CONSTRAINT fk_user_environment 
FOREIGN KEY (environment_id) REFERENCES environment(id);

-- Index
CREATE INDEX idx_user_environment ON apex_user(environment_id);
CREATE INDEX idx_user_tenant_env ON apex_user(tenant, environment_id);
```

#### 4.1.3 Migration Strategy

```sql
-- Migration script for existing users
-- Step 1: Create default environment for each tenant
INSERT INTO environment (id, name, tenant_id)
SELECT 
    gen_random_uuid()::text,
    'common',
    tenant_id
FROM tenant
WHERE NOT EXISTS (
    SELECT 1 FROM environment 
    WHERE environment.tenant_id = tenant.tenant_id 
    AND environment.name = 'common'
);

-- Step 2: Create realm mappings for default environment
INSERT INTO environment_realm_mapping (id, tenant_id, environment_id, realm_name)
SELECT 
    gen_random_uuid()::text,
    t.tenant_id,
    e.id,
    t.tenant_name || '-common'
FROM tenant t
JOIN environment e ON e.tenant_id = t.tenant_id AND e.name = 'common'
WHERE NOT EXISTS (
    SELECT 1 FROM environment_realm_mapping 
    WHERE tenant_id = t.tenant_id 
    AND environment_id = e.id
);

-- Step 3: Update existing users with default environment
UPDATE apex_user u
SET 
    environment_id = (
        SELECT e.id 
        FROM environment e 
        WHERE e.tenant_id = (SELECT tenant FROM apex_user WHERE user_id = u.user_id)
        AND e.name = 'common'
        LIMIT 1
    ),
    primary_environment = 'common',
    accessible_environments = ARRAY['common']
WHERE environment_id IS NULL;
```

### 4.2 Code Changes

#### 4.2.1 Core Components Requiring Changes

```
┌─────────────────────────────────────────────────────────┐
│         Components Impact Matrix                       │
└─────────────────────────────────────────────────────────┘

Component                    │ Impact │ Changes Required
─────────────────────────────┼────────┼──────────────────────────────────
KeyCloakClient               │ HIGH   │ Realm name builder, environment context
UserServiceImpl              │ HIGH   │ Environment-aware realm selection
LoginServiceForKeyCloakImpl  │ HIGH   │ Environment in token endpoints
KeyCloakOMConverter          │ MEDIUM │ No changes (realm-agnostic)
IDPConfig                    │ MEDIUM │ Support environment-specific config
TenantService                │ MEDIUM │ Environment-realm mapping management
EnvironmentService           │ MEDIUM │ Realm creation/deletion
ApexUser Model               │ HIGH   │ Add environment fields
UserRepository               │ MEDIUM │ Environment-based queries
TokenManager                 │ MEDIUM │ Environment in token requests
JWTUtility                   │ LOW    │ Extract environment from token
```

#### 4.2.2 Detailed Code Changes

**1. KeyCloakClient.java**

**Current:**
```java
public Keycloak getKeyCloak(IDPConfig idpConfig) {
    return buildWithClientCredentials(idpConfig);
}

private Keycloak buildWithClientCredentials(IDPConfig config) {
    return KeycloakBuilder.builder()
            .serverUrl(config.getIdpUrl())
            .realm(config.getTenantName()) // ❌ Uses tenant name only
            .grantType(OAuth2Constants.CLIENT_CREDENTIALS)
            .clientId(config.getIamClientId())
            .clientSecret(config.getIamClientSecret())
            .build();
}
```

**Proposed:**
```java
public Keycloak getKeyCloak(IDPConfig idpConfig, String environmentName) {
    String realmName = buildRealmName(idpConfig.getTenantName(), environmentName);
    return buildWithClientCredentials(idpConfig, realmName);
}

private Keycloak buildWithClientCredentials(IDPConfig config, String realmName) {
    return KeycloakBuilder.builder()
            .serverUrl(config.getIdpUrl())
            .realm(realmName) // ✅ Uses environment-specific realm
            .grantType(OAuth2Constants.CLIENT_CREDENTIALS)
            .clientId(config.getIamClientId())
            .clientSecret(config.getIamClientSecret())
            .build();
}

private String buildRealmName(String tenantName, String environmentName) {
    if (StringUtils.isBlank(environmentName) || "common".equals(environmentName)) {
        // Backward compatibility: use tenant name for "common" environment
        return tenantName;
    }
    return String.format("%s-%s", tenantName, environmentName);
}
```

**2. UserServiceImpl.java**

**Current:**
```java
private String addToKeycloak(UserDto userDto, Tenant tenant) throws IAMException {
    try (Keycloak keyCloak = keyCloakClient.getKeyCloak(idpConfig)) {
        UserRepresentation userRepresentation = KeyCloakOMConverter.toKeyCloakUser(userDto);
        RealmResource realmResource = keyCloak.realm(tenant.getTenantName()); // ❌
        UsersResource usersResource = realmResource.users();
        // ... create user
    }
}
```

**Proposed:**
```java
private String addToKeycloak(UserDto userDto, Tenant tenant, String environmentName) throws IAMException {
    String realmName = resolveRealmName(tenant, environmentName);
    try (Keycloak keyCloak = keyCloakClient.getKeyCloak(idpConfig, environmentName)) {
        UserRepresentation userRepresentation = KeyCloakOMConverter.toKeyCloakUser(userDto);
        RealmResource realmResource = keyCloak.realm(realmName); // ✅
        UsersResource usersResource = realmResource.users();
        // ... create user
    }
}

private String resolveRealmName(Tenant tenant, String environmentName) {
    if (StringUtils.isBlank(environmentName)) {
        environmentName = "common"; // Default for backward compatibility
    }
    return realmMappingService.getRealmName(tenant.getTenantId(), environmentName)
            .orElse(buildRealmName(tenant.getTenantName(), environmentName));
}
```

**3. LoginServiceForKeyCloakImpl.java**

**Current:**
```java
private String getTokenEndpoint(Tenant apexTenant) throws IAMException {
    Map<String, Object> wellKnownConfigMap = getWellKnownConfig(apexTenant.getTenantName()); // ❌
    // ...
}
```

**Proposed:**
```java
private String getTokenEndpoint(Tenant apexTenant, String environmentName) throws IAMException {
    String realmName = resolveRealmName(apexTenant, environmentName);
    Map<String, Object> wellKnownConfigMap = getWellKnownConfig(realmName); // ✅
    // ...
}

private String resolveRealmName(Tenant tenant, String environmentName) {
    if (StringUtils.isBlank(environmentName)) {
        environmentName = "common";
    }
    return realmMappingService.getRealmName(tenant.getTenantId(), environmentName)
            .orElse(buildRealmName(tenant.getTenantName(), environmentName));
}
```

**4. New Service: RealmMappingService**

```java
@Service
public class RealmMappingService {
    
    private final EnvironmentRealmMappingRepository realmMappingRepository;
    private final EnvironmentRepository environmentRepository;
    
    public Optional<String> getRealmName(String tenantId, String environmentName) {
        return environmentRepository.findByTenantIdAndName(tenantId, environmentName)
                .flatMap(env -> realmMappingRepository.findByTenantIdAndEnvironmentId(tenantId, env.getId())
                        .map(EnvironmentRealmMapping::getRealmName));
    }
    
    public String getOrCreateRealmName(String tenantId, String environmentName, String tenantName) {
        return getRealmName(tenantId, environmentName)
                .orElseGet(() -> {
                    String realmName = buildRealmName(tenantName, environmentName);
                    createRealmMapping(tenantId, environmentName, realmName);
                    return realmName;
                });
    }
    
    private void createRealmMapping(String tenantId, String environmentName, String realmName) {
        Environment environment = environmentRepository.findByTenantIdAndName(tenantId, environmentName)
                .orElseThrow(() -> new IAMNotFoundException("Environment not found"));
        
        EnvironmentRealmMapping mapping = EnvironmentRealmMapping.builder()
                .id(UUID.randomUUID().toString())
                .tenantId(tenantId)
                .environmentId(environment.getId())
                .realmName(realmName)
                .build();
        
        realmMappingRepository.save(mapping);
    }
    
    private String buildRealmName(String tenantName, String environmentName) {
        if ("common".equals(environmentName)) {
            return tenantName; // Backward compatibility
        }
        return String.format("%s-%s", tenantName, environmentName);
    }
}
```

---

## 5. API Changes

### 5.1 New Request Parameters

**User Creation API:**
```
POST /apexiam/v1/user
Headers:
  X-Tenant-Id: {tenantId}
  X-Environment-Name: {envName} (NEW - Optional for backward compatibility)
Body:
  {
    "userName": "john.doe",
    "email": "john@example.com",
    ...
  }
```

**User Update API:**
```
PATCH /apexiam/v1/user/{userId}
Headers:
  X-Tenant-Id: {tenantId}
  X-Environment-Name: {envName} (NEW - Optional)
```

**Login API:**
```
POST /apexiam/v1/login
Body:
  {
    "tenantId": "jiffy-default",
    "environmentName": "dev", (NEW - Optional)
    "username": "john.doe",
    "password": "password"
  }
```

### 5.2 Backward Compatibility

**Strategy:**
- If `environmentName` not provided → Use "common" environment
- "common" environment maps to original tenant realm name
- Existing APIs continue to work without changes
- New APIs can explicitly specify environment

**Implementation:**
```java
private String resolveEnvironment(String explicitEnv, Application application, String appInstanceId) {
    // Priority 1: Explicit parameter
    if (StringUtils.isNotBlank(explicitEnv)) {
        return explicitEnv;
    }
    
    // Priority 2: Application environment
    if (application != null && StringUtils.isNotBlank(application.getEnvironment())) {
        return application.getEnvironment();
    }
    
    // Priority 3: AppInstance mapping
    if (StringUtils.isNotBlank(appInstanceId)) {
        return appInstanceService.getEnvironment(appInstanceId)
                .orElse("common");
    }
    
    // Priority 4: Default (backward compatibility)
    return "common";
}
```

---

## 6. Keycloak Realm Management

### 6.1 Realm Creation Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Realm Creation Flow                            │
└─────────────────────────────────────────────────────────┘

Environment Creation/Activation
    │
    ├─► Check: Realm exists in Keycloak?
    │       │
    │       ├─► YES → Update mapping
    │       │
    │       └─► NO → Create Realm
    │               │
    │               ├─► Build: Realm Name
    │               │       └─► {tenantName}-{environmentName}
    │               │
    │               ├─► Create: Realm in Keycloak
    │               │       ├─► Realm Name
    │               │       ├─► Enabled: true
    │               │       └─► Default Settings
    │               │
    │               ├─► Create: Client (iam-client)
    │               │       ├─► Client ID: iam-client
    │               │       ├─► Client Secret: (from config)
    │               │       └─► Grant Types: client_credentials, password, authorization_code
    │               │
    │               └─► Store: Realm Mapping
    │                       └─► environment_realm_mapping table
```

### 6.2 Realm Configuration

**Default Realm Settings:**
```java
RealmRepresentation realm = new RealmRepresentation();
realm.setRealm(realmName);
realm.setEnabled(true);
realm.setRegistrationAllowed(false);
realm.setResetPasswordAllowed(true);
realm.setVerifyEmail(true);
realm.setLoginWithEmailAllowed(true);
realm.setDuplicateEmailsAllowed(false);
realm.setEditUsernameAllowed(false);
```

**Client Configuration:**
```java
ClientRepresentation client = new ClientRepresentation();
client.setClientId("iam-client");
client.setEnabled(true);
client.setClientAuthenticatorType("client-secret");
client.setSecret(clientSecret);
client.setStandardFlowEnabled(true);
client.setDirectAccessGrantsEnabled(true);
client.setServiceAccountsEnabled(true);
```

### 6.3 Realm Synchronization

**Realm Sync Service:**
```java
@Service
public class RealmSyncService {
    
    public void syncRealmForEnvironment(String tenantId, String environmentName) {
        Tenant tenant = tenantRepository.findById(tenantId)
                .orElseThrow(() -> new IAMNotFoundException("Tenant not found"));
        
        String realmName = buildRealmName(tenant.getTenantName(), environmentName);
        
        try (Keycloak keycloak = keyCloakClient.getKeyCloak(idpConfig, "common")) {
            RealmResource realmResource = keycloak.realm(realmName);
            
            // Check if realm exists
            try {
                realmResource.toRepresentation();
                log.info("Realm {} already exists", realmName);
            } catch (NotFoundException e) {
                // Create realm
                createRealm(realmName, tenant);
                log.info("Created realm {}", realmName);
            }
            
            // Ensure client exists
            ensureClientExists(realmResource, realmName);
        }
    }
    
    private void createRealm(String realmName, Tenant tenant) {
        RealmRepresentation realm = new RealmRepresentation();
        realm.setRealm(realmName);
        realm.setEnabled(true);
        // ... configure realm
        
        try (Keycloak keycloak = keyCloakClient.getKeyCloak(idpConfig, "common")) {
            keycloak.realms().create(realm);
        }
    }
}
```

---

## 7. Migration Strategy

### 7.1 Migration Phases

```
┌─────────────────────────────────────────────────────────┐
│         Migration Phases                               │
└─────────────────────────────────────────────────────────┘

Phase 1: Preparation (Week 1-2)
├─► Database schema changes
├─► Create "common" environment for all tenants
├─► Create realm mappings for "common" environment
└─► Update existing users with "common" environment

Phase 2: Code Deployment (Week 3-4)
├─► Deploy new code with backward compatibility
├─► Environment resolution logic
├─► Realm mapping service
└─► Updated Keycloak client methods

Phase 3: Keycloak Realm Creation (Week 5-6)
├─► Create environment-specific realms in Keycloak
├─► Configure clients for each realm
├─► Test realm connectivity
└─► Update realm mappings

Phase 4: User Migration (Week 7-8)
├─► Identify users by environment (if possible)
├─► Migrate users to environment-specific realms
├─► Update user referenceIds
└─► Verify user access

Phase 5: Validation & Rollback (Week 9-10)
├─► End-to-end testing
├─► Performance testing
├─► Rollback plan validation
└─► Production deployment
```

### 7.2 Data Migration Scripts

**1. Create Common Environments:**
```sql
-- Create "common" environment for each tenant
INSERT INTO environment (id, name, tenant_id)
SELECT 
    gen_random_uuid()::text,
    'common',
    tenant_id
FROM tenant
WHERE NOT EXISTS (
    SELECT 1 FROM environment 
    WHERE environment.tenant_id = tenant.tenant_id 
    AND environment.name = 'common'
);
```

**2. Create Realm Mappings:**
```sql
-- Create realm mapping for common environment
INSERT INTO environment_realm_mapping (id, tenant_id, environment_id, realm_name)
SELECT 
    gen_random_uuid()::text,
    t.tenant_id,
    e.id,
    t.tenant_name -- Use tenant name for "common" (backward compatibility)
FROM tenant t
JOIN environment e ON e.tenant_id = t.tenant_id AND e.name = 'common'
WHERE NOT EXISTS (
    SELECT 1 FROM environment_realm_mapping 
    WHERE tenant_id = t.tenant_id 
    AND environment_id = e.id
);
```

**3. Update Existing Users:**
```sql
-- Set default environment for existing users
UPDATE apex_user u
SET 
    environment_id = (
        SELECT e.id 
        FROM environment e 
        WHERE e.tenant_id = (SELECT tenant FROM apex_user WHERE user_id = u.user_id)
        AND e.name = 'common'
        LIMIT 1
    ),
    primary_environment = 'common',
    accessible_environments = ARRAY['common']
WHERE environment_id IS NULL;
```

### 7.3 Rollback Plan

**Rollback Strategy:**
1. **Code Rollback**: Revert to previous version
2. **Database Rollback**: Keep new schema (non-breaking)
3. **Keycloak Rollback**: Keep realms (can be unused)
4. **Data Rollback**: Users remain in "common" environment

**Rollback Scripts:**
```sql
-- Rollback: Set all users to common environment
UPDATE apex_user
SET 
    environment_id = (
        SELECT e.id 
        FROM environment e 
        WHERE e.tenant_id = (SELECT tenant FROM apex_user WHERE user_id = apex_user.user_id)
        AND e.name = 'common'
        LIMIT 1
    ),
    primary_environment = 'common'
WHERE primary_environment != 'common';
```

---

## 8. Development Effort Estimates

### 8.1 Effort Breakdown

```
┌─────────────────────────────────────────────────────────┐
│         Development Effort Summary                     │
└─────────────────────────────────────────────────────────┘

Category                    │ Tasks │ Effort (Days) │ Complexity
────────────────────────────┼───────┼──────────────┼─────────────
Database Changes            │   5   │      3       │ Medium
Core Service Changes        │  12   │     10       │ High
API Changes                 │   8   │      5       │ Medium
Keycloak Integration        │  10   │      8       │ High
Testing                     │  15   │     12       │ High
Migration Scripts           │   6   │      4       │ Medium
Documentation               │   4   │      3       │ Low
────────────────────────────┼───────┼──────────────┼─────────────
TOTAL                       │  60   │     45       │ High
```

### 8.2 Detailed Task Breakdown

#### 8.2.1 Database Changes (3 days)

| Task | Effort | Description |
|------|--------|-------------|
| Design schema changes | 0.5 days | Design new tables and modifications |
| Create migration scripts | 1 day | Liquibase changelogs |
| Test migrations | 0.5 days | Test on dev environment |
| Review and approval | 1 day | Code review and approval |

**Files to Create/Modify:**
- `db/changelog/vX.X.X/add-environment-realm-mapping.xml`
- `db/changelog/vX.X.X/add-user-environment-fields.xml`
- `db/changelog/vX.X.X/migrate-existing-users.xml`

#### 8.2.2 Core Service Changes (10 days)

| Task | Effort | Description |
|------|--------|-------------|
| Create RealmMappingService | 2 days | New service for realm management |
| Update KeyCloakClient | 1.5 days | Add environment parameter |
| Update UserServiceImpl | 2.5 days | Environment-aware user operations |
| Update LoginServiceForKeyCloakImpl | 2 days | Environment in authentication |
| Update TokenManager | 1 day | Environment in token requests |
| Update IDPConfig | 0.5 days | Support environment config |
| Update ApexUser model | 0.5 days | Add environment fields |

**Files to Modify:**
- `service/RealmMappingService.java` (NEW)
- `service/RealmSyncService.java` (NEW)
- `utility/KeyCloakClient.java`
- `service/UserServiceImpl.java`
- `service/LoginServiceForKeyCloakImpl.java`
- `utility/TokenManager.java`
- `config/IDPConfig.java`
- `model/ApexUser.java`
- `repository/EnvironmentRealmMappingRepository.java` (NEW)

#### 8.2.3 API Changes (5 days)

| Task | Effort | Description |
|------|--------|-------------|
| Update UserServiceController | 1.5 days | Add environment parameter |
| Update LoginController | 1 day | Add environment support |
| Update other controllers | 1 day | Environment context propagation |
| API documentation | 0.5 days | Update OpenAPI docs |
| Backward compatibility | 1 day | Ensure backward compatibility |

**Files to Modify:**
- `controller/UserServiceController.java`
- `controller/LoginController.java`
- `controller/MediatedLoginController.java`
- `controller/MediatorController.java`
- `dto/inbound/UserDto.java`
- `dto/inbound/LoginRequest.java`

#### 8.2.4 Keycloak Integration (8 days)

| Task | Effort | Description |
|------|--------|-------------|
| Realm creation service | 2 days | Automated realm creation |
| Client configuration | 1.5 days | Client setup per realm |
| Realm sync service | 2 days | Sync realms with database |
| Well-known config caching | 1 day | Per-realm configuration cache |
| Error handling | 1 day | Realm-specific error handling |
| Testing | 0.5 days | Integration testing |

**Files to Create/Modify:**
- `service/RealmSyncService.java` (NEW)
- `service/KeycloakRealmService.java` (NEW)
- `utility/KeyCloakClient.java`
- `service/LoginServiceForKeyCloakImpl.java`

#### 8.2.5 Testing (12 days)

| Task | Effort | Description |
|------|--------|-------------|
| Unit tests - Services | 3 days | Test all service changes |
| Unit tests - Utilities | 1.5 days | Test Keycloak client changes |
| Integration tests | 3 days | Test with Keycloak |
| API tests | 2 days | Test API changes |
| Migration tests | 1.5 days | Test migration scripts |
| Performance tests | 1 day | Test realm resolution performance |

**Test Files:**
- `test/java/.../service/RealmMappingServiceTest.java` (NEW)
- `test/java/.../service/RealmSyncServiceTest.java` (NEW)
- `test/java/.../service/UserServiceImplTest.java` (UPDATE)
- `test/java/.../service/LoginServiceForKeyCloakImplTest.java` (UPDATE)
- `test/java/.../utility/KeyCloakClientTest.java` (UPDATE)
- `test/integration/KeycloakRealmIntegrationTest.java` (NEW)

#### 8.2.6 Migration Scripts (4 days)

| Task | Effort | Description |
|------|--------|-------------|
| Data migration scripts | 2 days | SQL migration scripts |
| Keycloak realm creation | 1 day | Scripts for realm creation |
| Validation scripts | 0.5 days | Data validation |
| Rollback scripts | 0.5 days | Rollback procedures |

**Scripts:**
- `scripts/migration/create-common-environments.sql`
- `scripts/migration/create-realm-mappings.sql`
- `scripts/migration/update-existing-users.sql`
- `scripts/keycloak/create-realms.sh`
- `scripts/validation/validate-migration.sql`
- `scripts/rollback/rollback-migration.sql`

#### 8.2.7 Documentation (3 days)

| Task | Effort | Description |
|------|--------|-------------|
| Design documentation | 1 day | This document |
| API documentation | 0.5 days | Update API docs |
| Migration guide | 0.5 days | Migration procedures |
| Developer guide | 1 day | How to use new features |

**Documents:**
- `docs/design/multi-environment-realm-design.md` (THIS DOCUMENT)
- `docs/api/environment-support.md` (NEW)
- `docs/migration/environment-migration-guide.md` (NEW)
- `docs/developer/environment-usage-guide.md` (NEW)

### 8.3 Resource Requirements

**Team Composition:**
- **Backend Developer (Senior)**: 1 person, 6 weeks
- **Backend Developer (Mid)**: 1 person, 4 weeks
- **QA Engineer**: 1 person, 3 weeks
- **DevOps Engineer**: 0.5 person, 2 weeks (for Keycloak setup)

**Total Effort**: ~45 developer days (~9 weeks with 1 senior + 1 mid developer)

### 8.4 Risk Factors

| Risk | Impact | Mitigation | Additional Effort |
|------|--------|------------|-------------------|
| Keycloak realm creation failures | High | Automated retry, manual fallback | +2 days |
| Migration data inconsistencies | High | Validation scripts, rollback plan | +1 day |
| Performance degradation | Medium | Caching, optimization | +2 days |
| Backward compatibility issues | High | Extensive testing, gradual rollout | +3 days |
| Keycloak configuration complexity | Medium | Documentation, automation | +1 day |

**Contingency Buffer**: +10 days (20% of total effort)

**Total Estimated Effort**: **55 days** (~11 weeks)

---

## 9. Implementation Phases

### 9.1 Phase 1: Foundation (Weeks 1-2)

**Goals:**
- Database schema changes
- Basic realm mapping service
- Backward compatibility layer

**Deliverables:**
- ✅ Database migrations
- ✅ RealmMappingService
- ✅ Updated models
- ✅ Basic unit tests

### 9.2 Phase 2: Core Integration (Weeks 3-4)

**Goals:**
- Update Keycloak client
- Update user service
- Update login service

**Deliverables:**
- ✅ Updated KeyCloakClient
- ✅ Environment-aware user operations
- ✅ Environment-aware authentication
- ✅ Integration tests

### 9.3 Phase 3: Keycloak Setup (Weeks 5-6)

**Goals:**
- Realm creation automation
- Client configuration
- Realm synchronization

**Deliverables:**
- ✅ RealmSyncService
- ✅ Automated realm creation
- ✅ Client configuration scripts
- ✅ Keycloak integration tests

### 9.4 Phase 4: API & Migration (Weeks 7-8)

**Goals:**
- API updates
- Migration scripts
- Data migration

**Deliverables:**
- ✅ Updated APIs
- ✅ Migration scripts
- ✅ Data migration execution
- ✅ Validation scripts

### 9.5 Phase 5: Testing & Deployment (Weeks 9-11)

**Goals:**
- Comprehensive testing
- Performance optimization
- Production deployment

**Deliverables:**
- ✅ All tests passing
- ✅ Performance benchmarks
- ✅ Production deployment
- ✅ Monitoring and alerts

---

## 10. Testing Strategy

### 10.1 Test Coverage

```
┌─────────────────────────────────────────────────────────┐
│         Test Coverage Matrix                          │
└─────────────────────────────────────────────────────────┘

Test Type              │ Coverage │ Priority
────────────────────────┼──────────┼─────────────
Unit Tests              │   80%    │ High
Integration Tests       │   70%    │ High
API Tests               │   90%    │ High
Migration Tests         │  100%    │ Critical
Performance Tests       │   60%    │ Medium
Security Tests          │   70%    │ High
Backward Compatibility  │  100%    │ Critical
```

### 10.2 Key Test Scenarios

**1. Realm Resolution Tests:**
- ✅ Explicit environment parameter
- ✅ Application environment
- ✅ AppInstance environment mapping
- ✅ Default "common" environment
- ✅ Invalid environment handling

**2. User Management Tests:**
- ✅ User creation in specific environment
- ✅ User update with environment change
- ✅ User search across environments
- ✅ Username uniqueness per environment

**3. Authentication Tests:**
- ✅ Login with environment
- ✅ Token generation per environment
- ✅ Token validation per environment
- ✅ Token exchange across environments

**4. Migration Tests:**
- ✅ Existing users migration
- ✅ Realm mapping creation
- ✅ Data consistency validation
- ✅ Rollback procedures

---

## 11. Monitoring & Observability

### 11.1 Key Metrics

**Realm Operations:**
- Realm creation success/failure rate
- Realm resolution time
- Realm mapping cache hit rate

**User Operations:**
- User creation per environment
- User sync success rate
- Username conflict rate

**Authentication:**
- Login success rate per environment
- Token generation time
- Token validation failures

### 11.2 Alerts

**Critical Alerts:**
- Realm creation failures
- Realm resolution failures
- User sync failures
- Migration failures

**Warning Alerts:**
- High realm resolution latency
- Cache miss rate > 20%
- Username conflicts

---

## 12. Summary

### 12.1 Design Summary

**Current State:**
- 1 Tenant = 1 Keycloak Realm
- No environment-level isolation
- Username conflicts across environments

**Target State:**
- 1 Tenant × N Environments = N Keycloak Realms
- Environment-level isolation
- Username uniqueness per environment

**Realm Naming:** `{tenantName}-{environmentName}`

### 12.2 Key Changes

1. **Database**: New tables for realm mapping, environment fields in users
2. **Services**: Environment-aware realm resolution
3. **APIs**: Optional environment parameter (backward compatible)
4. **Keycloak**: Automated realm creation and management

### 12.3 Effort Summary

- **Total Effort**: 55 days (~11 weeks)
- **Team**: 1 Senior + 1 Mid Developer + 1 QA + 0.5 DevOps
- **Phases**: 5 phases over 11 weeks
- **Risk Buffer**: 10 days included

### 12.4 Success Criteria

✅ All existing APIs work without changes (backward compatibility)  
✅ New environment-specific realms created in Keycloak  
✅ Users can be created per environment  
✅ No username conflicts across environments  
✅ All tests passing  
✅ Migration completed successfully  
✅ Performance within acceptable limits  

---

**Document Version**: 1.0  
**Last Updated**: 2025  
**Status**: Design Proposal  
**Next Steps**: Review, approval, and implementation planning
