# Token Management - Part 5: Token Lifecycle and Best Practices

## Overview

This document covers the complete token lifecycle management in Apex IAM, including token invalidation, caching strategies, lifecycle management, security best practices, and operational considerations.

---

## 1. Token Lifecycle Overview

### 1.1 Complete Token Lifecycle

```
┌─────────────────────────────────────────────────────────┐
│         Token Lifecycle Stages                         │
└─────────────────────────────────────────────────────────┘

1. Token Generation
   ├─► User authentication
   ├─► Token issuance
   └─► Token storage (client-side)

2. Token Usage
   ├─► API requests
   ├─► Authorization checks
   └─► Permission validation

3. Token Refresh
   ├─► Expiry detection
   ├─► Refresh token usage
   └─► New token issuance

4. Token Invalidation
   ├─► User logout
   ├─► Security breach
   ├─► Token revocation
   └─► Expiry

5. Token Cleanup
   ├─► Cache invalidation
   ├─► Session cleanup
   └─► Audit logging
```

### 1.2 Token States

```
┌─────────────────────────────────────────────────────────┐
│         Token States                                    │
└─────────────────────────────────────────────────────────┘

VALID
    │
    ├─► Active and usable
    ├─► Not expired
    ├─► Not invalidated
    └─► User enabled

EXPIRED
    │
    ├─► Past expiry time
    ├─► Cannot be used
    └─► Must refresh

INVALIDATED
    │
    ├─► Explicitly revoked
    ├─► User logged out
    ├─► Security incident
    └─► Cannot be used

REFRESHED
    │
    ├─► Replaced by new token
    ├─► Old token invalidated
    └─► New token active
```

---

## 2. Token Invalidation

### 2.1 Invalidation Scenarios

```
┌─────────────────────────────────────────────────────────┐
│         Token Invalidation Scenarios                   │
└─────────────────────────────────────────────────────────┘

1. User Logout
   ├─► Explicit logout request
   ├─► Invalidate access token
   ├─► Invalidate refresh token
   └─► Clear session

2. Security Breach
   ├─► Suspicious activity detected
   ├─► Token compromise suspected
   ├─► Force token invalidation
   └─► Require re-authentication

3. User Disabled
   ├─► Admin disables user
   ├─► All tokens invalidated
   └─► Access denied

4. Password Change
   ├─► User changes password
   ├─► Existing tokens invalidated
   └─► Require new login

5. Token Expiry
   ├─► Natural expiration
   ├─► Automatic invalidation
   └─► Refresh required
```

### 2.2 Invalidation Flow

```
┌─────────────────────────────────────────────────────────┐
│         Token Invalidation Flow                       │
└─────────────────────────────────────────────────────────┘

POST /apexiam/v1/login/logout
    │
    ├─► Headers:
    │       ├─► Authorization: Bearer {token}
    │       └─► X-Tenant-Id: {tenantId}
    │
    ├─► Body (optional):
    │       └─► { "message": "User logout" }
    │
    ▼
LoginServiceForKeyCloakImpl.invalidateAccessToken()
    │
    ├─► Extract: Access Token
    │       └─► jwtUtility.getAccessToken(authToken)
    │
    ├─► Resolve: App/Tenant Context
    │       └─► resolveAppTenantFromHost(host)
    │
    ├─► Normalize: Token
    │       └─► normalizeToken(accessToken, tenant, app)
    │
    ├─► Decode: Token
    │       └─► jwtUtility.getDecodedJwtFromToken()
    │
    ├─► Extract: User Information
    │       ├─► Subject (user ID)
    │       ├─► Tenant
    │       └─► Application
    │
    ├─► Invalidate: User Cache
    │       └─► cacheService.deleteAll(cacheKeyUserContext)
    │               └─► Delete all user-related cache
    │
    ├─► Mark: Token as Invalid
    │       ├─► Cache Key: TOKEN_PREFIX + SHA256(token)
    │       ├─► Cache Value: { "status": "invalid" }
    │       └─► Cache TTL: Token remaining validity
    │
    └─► Return: Success
```

**Code Implementation:**
```java
@Override
public void invalidateAccessToken(HttpServletRequest request, String authToken, String message) {
    // Extract and normalize token
    String accessToken = jwtUtility.getAccessToken(authToken);
    AppTenantContext appTenantContext = resolveAppTenantFromHost(request.getServerName());
    Tenant tenant = appTenantContext.tenant;
    Application app = appTenantContext.application;
    accessToken = normalizeToken(accessToken, tenant, app);
    
    // Decode token
    DecodedJWT decodedJWT = jwtUtility.getDecodedJwtFromToken(accessToken);
    String subject = jwtUtility.getSubject(decodedJWT);
    
    // Get user ID
    IdProvider idProvider = idProviderService.getIdProviderFromToken(accessToken, tenant);
    String userId;
    if (idProvider != null && idProvider.isExternalTokenIssuer()) {
        userId = fetchUserFromToken(decodedJWT, tenant, idProvider).getUserId();
    } else {
        userId = apexIamUtility.findUserByReferenceId(subject).getUserId();
    }
    
    // Invalidate user cache
    CacheKeyContext cacheKeyUserContext = CacheKeyContext.tenantAppUser(
        tenant.getTenantId(), app.getApplicationId(), userId);
    cacheService.deleteAll(cacheKeyUserContext);
    
    // Mark token as invalid
    CacheKeyContext cacheKeyContext = CacheKeyContext.tenant(jwtUtility.getIssuer(decodedJWT));
    String tokenCacheKey = TOKEN_PREFIX + apexIamUtility.createSHAHash(accessToken);
    
    Duration expiry = Duration.ofMillis(jwtUtility.getTokenRemainingValidityMillis(decodedJWT));
    String cachedData = cacheService.get(cacheKeyContext, tokenCacheKey);
    
    if (cachedData != null) {
        Map<String, String> cache = objectMapper.readValue(cachedData, TYPE_REF_MAP_STRING_TO_STRING);
        cache.put(TOKEN_STATUS, TOKEN_STATUS_INVALID);
        cacheService.set(cacheKeyContext, tokenCacheKey, 
            objectMapper.writeValueAsString(cache), expiry);
    } else {
        HashMap<String, String> hashMap = new HashMap<>();
        hashMap.put(TOKEN_STATUS, TOKEN_STATUS_INVALID);
        cacheService.set(cacheKeyContext, tokenCacheKey, 
            objectMapper.writeValueAsString(hashMap), expiry);
    }
    
    log.info("Token invalidated for subject: {} with message: {}", subject, message);
}
```

### 2.3 Invalidation Check

```
┌─────────────────────────────────────────────────────────┐
│         Token Invalidation Check                       │
└─────────────────────────────────────────────────────────┘

ExtAuthzService.check()
    │
    ├─► Extract: Token
    │
    ├─► Check: Token Invalidated?
    │       └─► isTokenInvalidated(accessToken)
    │               │
    │               ├─► Build: Cache Key
    │               │       └─► TOKEN_PREFIX + SHA256(token)
    │               │
    │               ├─► Get: Token Status from Cache
    │               │       └─► cacheService.get(cacheKeyContext, tokenCacheKey)
    │               │
    │               └─► Check: Status == "invalid"?
    │                       ├─► YES → Return DENY (401)
    │                       └─► NO → Continue validation
    │
    └─► Continue: Normal validation flow
```

**Code Implementation:**
```java
private boolean isTokenInvalidated(String accessToken, CacheKeyContext cacheKeyContext) {
    String tokenCacheKey = TOKEN_PREFIX + apexIamUtility.createSHAHash(accessToken);
    String cachedData = cacheService.get(cacheKeyContext, tokenCacheKey);
    
    if (StringUtils.isNotBlank(cachedData)) {
        try {
            Map<String, String> cache = objectMapper.readValue(cachedData, TYPE_REF_MAP_STRING_TO_STRING);
            return cache.containsKey(TOKEN_STATUS) && 
                   cache.get(TOKEN_STATUS).equalsIgnoreCase(TOKEN_STATUS_INVALID);
        } catch (Exception e) {
            log.warn("Failed to parse token cache data", e);
        }
    }
    return false;
}
```

---

## 3. Token Caching Strategy

### 3.1 Cache Architecture

```
┌─────────────────────────────────────────────────────────┐
│         Token Cache Architecture                       │
└─────────────────────────────────────────────────────────┘

Cache Layers:
├─► Layer 1: Decrypted Token Cache
│   ├─► Key: TOKEN_PREFIX + SHA256(encryptedToken)
│   ├─► Value: Decrypted JWT token
│   ├─► TTL: Token expiry duration
│   └─► Purpose: Avoid repeated decryption
│
├─► Layer 2: Token Status Cache
│   ├─► Key: TOKEN_PREFIX + SHA256(token)
│   ├─► Value: { "status": "invalid" }
│   ├─► TTL: Token remaining validity
│   └─► Purpose: Track invalidated tokens
│
├─► Layer 3: SSO Token Cache
│   ├─► Key: TOKEN_PREFIX + SHA256(token)
│   ├─► Value: { "firstLogin": "true", ... }
│   ├─► TTL: Token expiry duration
│   └─► Purpose: Track SSO session state
│
└─► Layer 4: User Permission Cache
    ├─► Key: uiPerms:{tokenHash} or roles:{tokenHash}
    ├─► Value: User permissions/roles
    ├─► TTL: Token expiry duration
    └─► Purpose: Cache user permissions
```

### 3.2 Cache Key Structure

```
┌─────────────────────────────────────────────────────────┐
│         Cache Key Hierarchy                            │
└─────────────────────────────────────────────────────────┘

Cache Key Context:
├─► Tenant Level
│   └─► Key: tenant:{tenantId}
│
├─► Tenant + Application Level
│   └─► Key: tenant:{tenantId}:app:{appId}
│
└─► Tenant + Application + User Level
    └─► Key: tenant:{tenantId}:app:{appId}:user:{userId}

Cache Key Parts:
├─► Context: CacheKeyContext (hierarchical)
├─► Field: Specific field key (e.g., "uiPerms:{hash}")
└─► Full Key: context + field

Example:
├─► Context: tenant:jiffy-default:app:app-123:user:user-456
├─► Field: uiPerms:abc123...
└─► Full Key: tenant:jiffy-default:app:app-123:user:user-456:uiPerms:abc123...
```

### 3.3 Cache Operations

**Cache Write:**
```java
// Cache decrypted token
cacheService.set(cacheKeyContext, tokenCacheKey, decryptedToken, tokenExpiryDuration);

// Cache token status
cacheService.set(cacheKeyContext, tokenCacheKey, 
    objectMapper.writeValueAsString(statusMap), expiry);

// Cache user permissions
cacheService.set(cacheKeyContext, permissionsKey, permissions, tokenExpiryDuration);
```

**Cache Read:**
```java
// Read decrypted token
String cachedToken = cacheService.get(cacheKeyContext, tokenCacheKey);

// Read token status
String cachedData = cacheService.get(cacheKeyContext, tokenCacheKey);
Map<String, String> status = objectMapper.readValue(cachedData, TYPE_REF_MAP_STRING_TO_STRING);

// Read permissions
List<ApexPermissionDto> permissions = cacheService.getConvertedCache(
    cacheKeyContext, permissionsKey, new TypeReference<>() {});
```

**Cache Invalidation:**
```java
// Invalidate all user cache
cacheService.deleteAll(cacheKeyUserContext);

// Invalidate specific key
cacheService.delete(cacheKeyContext, specificKey);
```

---

## 4. Service Account Token Management

### 4.1 Service Token Lifecycle

```
┌─────────────────────────────────────────────────────────┐
│         Service Account Token Lifecycle                │
└─────────────────────────────────────────────────────────┘

TokenManager.getAccessToken()
    │
    ├─► Check: Local Cache
    │       └─► ConcurrentHashMap<String, String>
    │
    ├─► If Cached:
    │       ├─► Decode: Token
    │       ├─► Check: Expiry with Grace Period
    │       │       └─► expiresAt - graceTime < currentTime?
    │       │               ├─► YES → Refresh token
    │       │               └─► NO → Return cached token
    │       │
    │       └─► Return: Cached token
    │
    └─► If Not Cached or Expiring:
            ├─► Fetch: New Token
            │       └─► apexIAMUtility.accessToken(tenant, clientId, secret)
            │               └─► POST Keycloak token endpoint
            │                       └─► Grant: client_credentials
            │
            ├─► Cache: New Token
            │
            └─► Return: New Token
```

**Code Implementation:**
```java
public String getAccessToken(String tenantName, String clientId, String clientSecret) {
    return localCache.compute(ACCESS_TOKEN_CACHE_KEY, (key, val) -> {
        if (StringUtils.hasText(val) && jwtUtility.getAccessToken(val) != null) {
            // Check expiry with grace period
            DecodedJWT decodedToken = jwtUtility.getDecodedJwtFromToken(
                jwtUtility.getAccessToken(val));
            Instant expiresAt = decodedToken.getExpiresAt().toInstant();
            Instant expiresAtWithGrace = expiresAt.minusSeconds(graceTimeForTokenExpireInSeconds);
            Instant current = Instant.now();
            
            boolean expiring = expiresAtWithGrace.isBefore(current);
            if (expiring) {
                // Refresh token
                val = apexIAMUtility.accessToken(tenantName, clientId, clientSecret);
            }
        } else {
            // Fetch new token
            val = apexIAMUtility.accessToken(tenantName, clientId, clientSecret);
        }
        return val;
    });
}
```

### 4.2 Grace Period Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Grace Period Concept                            │
└─────────────────────────────────────────────────────────┘

Token Expiry: 2 hours
Grace Period: 5 minutes (300 seconds)

Timeline:
├─► Token Issued: T=0
├─► Token Expires: T=2 hours
├─► Grace Period Starts: T=2 hours - 5 minutes
│
└─► Token Refresh Decision:
    ├─► T < (2h - 5m): Use cached token
    ├─► T >= (2h - 5m): Refresh token
    └─► T >= 2h: Token expired (must refresh)

Benefits:
├─► Proactive refresh
├─► Avoid expired token usage
├─► Smooth token transition
└─► No service interruption
```

**Configuration:**
```yaml
service-account:
  graceTimeForTokenExpireInSeconds: 300  # 5 minutes
```

---

## 5. Token Lifecycle Management

### 5.1 Token State Transitions

```
┌─────────────────────────────────────────────────────────┐
│         Token State Machine                            │
└─────────────────────────────────────────────────────────┘

                    [INITIAL]
                       │
                       │ User Login
                       ▼
                   [ACTIVE]
                       │
        ┌──────────────┼──────────────┐
        │              │              │
        │              │              │
        ▼              ▼              ▼
   [EXPIRING]    [INVALIDATED]   [EXPIRED]
        │              │              │
        │              │              │
        │              └──────────────┘
        │                    │
        │              [REVOKED]
        │                    │
        │                    │
        ▼                    ▼
   [REFRESHED]         [TERMINATED]
        │
        │ New Token Issued
        ▼
   [ACTIVE] (new token)
```

### 5.2 Lifecycle Operations

**1. Token Creation:**
- User authenticates
- Token issued by Keycloak
- Token cached (if applicable)
- Token returned to client

**2. Token Usage:**
- Client includes token in requests
- IAM validates token
- Token checked for expiry
- Token checked for invalidation
- Request authorized

**3. Token Refresh:**
- Token approaching expiry
- Client uses refresh token
- New tokens issued
- Old token invalidated
- New token cached

**4. Token Invalidation:**
- User logs out
- Security incident
- User disabled
- Token marked invalid in cache
- Token cannot be used

**5. Token Cleanup:**
- Expired tokens removed from cache
- Invalid tokens expire from cache
- Old sessions cleaned up
- Audit logs maintained

---

## 6. Token Security Best Practices

### 6.1 Token Storage

```
┌─────────────────────────────────────────────────────────┐
│         Token Storage Best Practices                   │
└─────────────────────────────────────────────────────────┘

Client-Side Storage:
├─► Memory (Preferred)
│   ├─► In-memory variables
│   ├─► Not persisted
│   └─► Cleared on page close
│
├─► Secure HTTP-Only Cookies
│   ├─► httpOnly: true
│   ├─► secure: true (HTTPS only)
│   ├─► sameSite: strict
│   └─► Not accessible via JavaScript
│
└─► Avoid:
    ├─► localStorage (XSS risk)
    ├─► sessionStorage (XSS risk)
    └─► URL parameters (exposure risk)
```

### 6.2 Token Transmission

```
┌─────────────────────────────────────────────────────────┐
│         Token Transmission Security                   │
└─────────────────────────────────────────────────────────┘

1. Always Use HTTPS
   ├─► Encrypt token in transit
   ├─► Prevent man-in-the-middle
   └─► Secure channel required

2. Use Authorization Header
   ├─► Header: Authorization: Bearer {token}
   ├─► Not in URL parameters
   └─► Not in query strings

3. Token Rotation
   ├─► Refresh tokens regularly
   ├─► Short-lived access tokens
   └─► Rotate refresh tokens

4. Token Validation
   ├─► Always validate on server
   ├─► Check expiry
   ├─► Verify signature
   └─► Check invalidation status
```

### 6.3 Token Expiry Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Token Expiry Configuration                     │
└─────────────────────────────────────────────────────────┘

Access Token:
├─► Lifetime: 2 hours (default)
├─► Short-lived for security
├─► Refresh before expiry
└─► Grace period: 5 minutes

Refresh Token:
├─► Lifetime: 30 days (default)
├─► Long-lived for UX
├─► Revocable
└─► Rotated on use (optional)

Service Account Token:
├─► Lifetime: 2 hours
├─► Auto-refresh with grace period
├─► Cached for performance
└─► Grace period: 5 minutes
```

---

## 7. Token Monitoring and Observability

### 7.1 Key Metrics

```
┌─────────────────────────────────────────────────────────┐
│         Token Metrics                                  │
└─────────────────────────────────────────────────────────┘

Token Generation Metrics:
├─► Token generation rate
├─► Token generation latency
├─► Token generation failures
└─► Token generation by grant type

Token Validation Metrics:
├─► Token validation rate
├─► Token validation latency
├─► Token validation failures
├─► Expired token attempts
└─► Invalid token attempts

Token Refresh Metrics:
├─► Token refresh rate
├─► Token refresh latency
├─► Token refresh failures
└─► Refresh token usage

Token Invalidation Metrics:
├─► Token invalidation rate
├─► Invalidation by reason
├─► Invalid token usage attempts
└─► Cache hit/miss rates
```

### 7.2 Logging Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Token Logging                                  │
└─────────────────────────────────────────────────────────┘

What to Log:
├─► Token generation events
│   ├─► User ID, tenant, app
│   ├─► Grant type
│   └─► Success/failure
│
├─► Token validation events
│   ├─► Validation result
│   ├─► Failure reasons
│   └─► Performance metrics
│
├─► Token refresh events
│   ├─► Refresh success/failure
│   ├─► Refresh latency
│   └─► Token rotation
│
├─► Token invalidation events
│   ├─► Invalidation reason
│   ├─► User ID, tenant
│   └─► Timestamp
│
└─► Security Events
    ├─► Invalid token attempts
    ├─► Expired token usage
    ├─► Token compromise attempts
    └─► Unusual patterns

What NOT to Log:
├─► Full token values
├─► Token secrets
├─► Client secrets
└─► Sensitive claims
```

### 7.3 Alerting

```
┌─────────────────────────────────────────────────────────┐
│         Token Alerts                                   │
└─────────────────────────────────────────────────────────┘

Critical Alerts:
├─► High token generation failures (> 5%)
├─► High token validation failures (> 10%)
├─► Token compromise detected
└─► Service account token failures

Warning Alerts:
├─► High expired token usage
├─► High invalid token attempts
├─► Unusual token refresh patterns
└─► Cache miss rate > 20%

Info Alerts:
├─► Token generation rate spikes
├─► Token validation latency increase
└─► Token refresh rate changes
```

---

## 8. Token Performance Optimization

### 8.1 Caching Optimization

```
┌─────────────────────────────────────────────────────────┐
│         Cache Optimization Strategies                  │
└─────────────────────────────────────────────────────────┘

1. Hierarchical Caching
   ├─► Tenant → App → User hierarchy
   ├─► Efficient key structure
   └─► Bulk invalidation support

2. TTL Optimization
   ├─► Match TTL to token expiry
   ├─► Avoid over-caching
   └─► Automatic cleanup

3. Cache Warming
   ├─► Pre-cache common tokens
   ├─► Warm cache on login
   └─► Background refresh

4. Cache Invalidation
   ├─► Invalidate on logout
   ├─► Invalidate on user disable
   └─► Efficient invalidation patterns
```

### 8.2 Token Validation Optimization

```
┌─────────────────────────────────────────────────────────┐
│         Validation Optimization                        │
└─────────────────────────────────────────────────────────┘

1. Early Validation
   ├─► Check format first
   ├─► Check expiry early
   └─► Fail fast

2. Cached Validation
   ├─► Cache validation results
   ├─► Cache decrypted tokens
   └─► Reduce processing

3. Parallel Processing
   ├─► Parallel cache lookups
   ├─► Parallel validation checks
   └─► Reduce latency

4. Batch Operations
   ├─► Batch cache reads
   ├─► Batch permission checks
   └─► Reduce round trips
```

---

## 9. Token Error Handling

### 9.1 Error Scenarios

```
┌─────────────────────────────────────────────────────────┐
│         Token Error Handling                          │
└─────────────────────────────────────────────────────────┘

Error Type              │ HTTP Status │ Response
────────────────────────┼─────────────┼─────────────────────────────
Invalid Token Format    │ 401         │ "Invalid token format"
Token Expired           │ 401         │ "Token expired"
Token Invalidated       │ 401         │ "Token has been revoked"
Invalid Signature       │ 401         │ "Invalid token signature"
Missing Token           │ 401         │ "Authorization token required"
Invalid Claims          │ 401         │ "Token missing required claims"
User Disabled           │ 403         │ "User account disabled"
Permission Denied       │ 403         │ "Insufficient permissions"
Token Decryption Failed │ 401         │ "Token decryption failed"
```

### 9.2 Error Response Format

```json
{
  "error": "invalid_token",
  "error_description": "Token has expired",
  "error_code": 401,
  "timestamp": "2025-01-15T10:30:00Z"
}
```

---

## 10. Token Best Practices Summary

### 10.1 Security Best Practices

1. **Token Storage**
   - ✅ Use memory or secure HTTP-only cookies
   - ❌ Never use localStorage/sessionStorage
   - ❌ Never include in URLs

2. **Token Transmission**
   - ✅ Always use HTTPS
   - ✅ Use Authorization header
   - ❌ Never in query parameters

3. **Token Lifetime**
   - ✅ Short-lived access tokens (2 hours)
   - ✅ Long-lived refresh tokens (30 days)
   - ✅ Auto-refresh before expiry

4. **Token Validation**
   - ✅ Always validate on server
   - ✅ Check expiry and invalidation
   - ✅ Verify signature for external tokens

5. **Token Invalidation**
   - ✅ Invalidate on logout
   - ✅ Invalidate on security incidents
   - ✅ Track invalidation in cache

### 10.2 Performance Best Practices

1. **Caching**
   - ✅ Cache decrypted tokens
   - ✅ Cache validation results
   - ✅ Use hierarchical cache keys
   - ❌ Don't cache exchanged tokens

2. **Optimization**
   - ✅ Early validation (fail fast)
   - ✅ Parallel processing
   - ✅ Batch operations
   - ✅ Grace period for service tokens

3. **Monitoring**
   - ✅ Track token metrics
   - ✅ Monitor cache hit rates
   - ✅ Alert on anomalies
   - ✅ Log security events

### 10.3 Operational Best Practices

1. **Configuration**
   - ✅ Configurable token lifetimes
   - ✅ Configurable grace periods
   - ✅ Environment-specific configs

2. **Error Handling**
   - ✅ Clear error messages
   - ✅ Proper HTTP status codes
   - ✅ Error logging
   - ✅ Don't expose sensitive info

3. **Documentation**
   - ✅ API documentation
   - ✅ Error code documentation
   - ✅ Integration guides
   - ✅ Troubleshooting guides

---

## 11. Token Lifecycle Summary

### 11.1 Complete Lifecycle Flow

```
┌─────────────────────────────────────────────────────────┐
│         Complete Token Lifecycle                       │
└─────────────────────────────────────────────────────────┘

1. GENERATION
   User Login → Keycloak → Token Issued → Client Storage

2. USAGE
   API Request → Token Validation → Authorization → Response

3. REFRESH
   Token Expiring → Refresh Request → New Token → Update Storage

4. INVALIDATION
   Logout/Security → Mark Invalid → Cache Update → Access Denied

5. CLEANUP
   Token Expired → Cache Cleanup → Audit Log → Session End
```

### 11.2 Key Components

| Component | Responsibility |
|-----------|----------------|
| **JWTUtility** | Token decoding, claim extraction, expiry checks |
| **TokenManager** | Service account token caching and refresh |
| **LoginService** | Token generation, refresh, exchange, invalidation |
| **ExtAuthzService** | Token validation, authorization checks |
| **CacheService** | Token caching, invalidation tracking |
| **Keycloak** | Token issuance, validation, exchange |

---

## Summary

**Key Points:**
- Complete token lifecycle: Generation → Usage → Refresh → Invalidation → Cleanup
- Token invalidation: Logout, security, user disable, password change
- Caching strategy: Multi-layer caching for performance
- Service tokens: Auto-refresh with grace period
- Security: HTTPS, secure storage, token rotation
- Monitoring: Metrics, logging, alerting

**Lifecycle Management:**
1. Generate tokens securely
2. Validate tokens on every request
3. Refresh tokens before expiry
4. Invalidate tokens on logout/security
5. Clean up expired tokens

**Best Practices:**
- ✅ Secure token storage and transmission
- ✅ Short-lived access tokens
- ✅ Comprehensive validation
- ✅ Efficient caching
- ✅ Proper error handling
- ✅ Monitoring and alerting

**This completes the 5-part Token Management series covering:**
- Part 1: Token Generation and Acquisition
- Part 2: Token Validation and Decoding
- Part 3: Token Refresh and Renewal
- Part 4: Token Exchange and Transformation
- Part 5: Token Lifecycle and Best Practices
