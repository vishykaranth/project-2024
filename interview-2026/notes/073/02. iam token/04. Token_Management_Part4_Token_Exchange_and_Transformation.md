# Token Management - Part 4: Token Exchange and Transformation

## Overview

This document explains how the Apex IAM system handles token exchange and transformation, including impersonation flows, magic link tokens, and cross-client token exchange scenarios.

---

## 1. Token Exchange Overview

### 1.1 What is Token Exchange?

```
┌─────────────────────────────────────────────────────────┐
│         Token Exchange Concept                          │
└─────────────────────────────────────────────────────────┘

Token Exchange = Converting one token into another token
    │
    ├─► Different client context
    ├─► Different subject (impersonation)
    ├─► Different scopes/permissions
    └─► Different token format

Use Cases:
├─► Impersonation (admin acting as user)
├─► Cross-client access (platform → application)
├─► Magic link authentication
└─► Service-to-service delegation
```

### 1.2 Token Exchange Standards

**OAuth 2.0 Token Exchange (RFC 8693):**
- Standard protocol for token exchange
- Subject token → Requested token
- Supports different token types
- Keycloak implements this standard

**Keycloak Token Exchange:**
- Grant type: `urn:ietf:params:oauth:grant-type:token-exchange`
- Subject token: Original token
- Requested subject: Target user (for impersonation)
- Target client: Destination application

---

## 2. Token Exchange Flows

### 2.1 Standard Token Exchange Flow

```
┌─────────────────────────────────────────────────────────┐
│         Standard Token Exchange Flow                   │
└─────────────────────────────────────────────────────────┘

Client Application
    │
    ├─► Has: Access Token (for client A)
    │
    ├─► Needs: Access Token (for client B)
    │
    ├─► POST /apexiam/v1/login/token-exchange
    │       Headers:
    │         X-Tenant-Id: {tenantId}
    │         Authorization: Bearer {currentToken}
    │       Body:
    │       {
    │         "grantType": "urn:ietf:params:oauth:grant-type:token-exchange",
    │         "subjectToken": "{currentToken}",
    │         "subjectTokenType": "urn:ietf:params:oauth:token-type:access_token",
    │         "requestedTokenType": "urn:ietf:params:oauth:token-type:access_token",
    │         "targetClient": "{targetAppId}",
    │         "clientId": "{impersonationClientId}",
    │         "clientSecret": "{impersonationClientSecret}"
    │       }
    │
    ▼
LoginServiceForKeyCloakImpl.exchangeToken()
    │
    ├─► Validate: Tenant
    │       └─► getTenant(tenant)
    │
    ├─► Get: Token Endpoint
    │       └─► getWellKnownConfig(tenantName)
    │
    ├─► Extract: Subject Token
    │       └─► jwtUtility.getAccessToken(token)
    │
    ├─► Build: Exchange Request
    │       ├─► Grant Type: token-exchange
    │       ├─► Subject Token: {currentToken}
    │       ├─► Target Client: {targetAppId}
    │       └─► Client Credentials
    │
    ├─► POST: Keycloak Token Endpoint
    │       └─► /realms/{tenant}/protocol/openid-connect/token
    │
    ├─► Receive: New Token Response
    │       ├─► access_token (for target client)
    │       ├─► refresh_token
    │       └─► expires_in
    │
    └─► Return: TokenResponse
```

**Code Implementation:**
```java
@Override
public TokenResponse exchangeToken(String tenant, String token, ExchangeTokenRequest exchangeTokenRequest) {
    Tenant apexTenant = getTenant(tenant);
    Map<String, Object> wellKnownConfigMap = getWellKnownConfig(apexTenant.getTenantName());
    String tokenUri = (String) wellKnownConfigMap.get(KEY_CLOAK_TOKEN_ENDPOINT);
    
    // Extract subject token
    String actualSubjectToken = jwtUtility.getAccessToken(token);
    
    // Build request
    HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(tokenUri))
            .header(CONTENT_TYPE, APPLICATION_FORM_URLENCODED_VALUE)
            .POST(ofFormData(exchangeTokenRequest, actualSubjectToken))
            .build();
    
    // Execute exchange
    HttpResponse<String> response = processHttpClient(request, KEY_CLOAK_TOKEN_ENDPOINT);
    return objectMapper.readValue(response.body(), TokenResponse.class);
}
```

### 2.2 Impersonation Token Exchange Flow

```
┌─────────────────────────────────────────────────────────┐
│         Impersonation Token Exchange Flow              │
└─────────────────────────────────────────────────────────┘

Admin/Service Account
    │
    ├─► Needs: Act as another user
    │
    ├─► performTokenExchange(tenant, requestedSubject, applicationId)
    │       │
    │       ├─► Step 1: Get Impersonation Client Credentials
    │       │       └─► fetchConfigSecrets.fetchProviderSecretsForTenant()
    │       │               ├─► clientId: impersonation-client
    │       │               └─► clientSecret: {secret}
    │       │
    │       ├─► Step 2: Generate Subject Token
    │       │       ├─► Grant Type: client_credentials
    │       │       ├─► Client ID: impersonation-client
    │       │       ├─► Client Secret: {secret}
    │       │       └─► Scope: openid email profile
    │       │
    │       ├─► Step 3: Exchange Token
    │       │       ├─► Grant Type: token-exchange
    │       │       ├─► Subject Token: {serviceToken}
    │       │       ├─► Requested Subject: {userId} (Keycloak referenceId)
    │       │       ├─► Target Client: {applicationId}
    │       │       └─► Token Type: access_token
    │       │
    │       └─► Step 4: Receive Impersonation Token
    │               └─► Token issued for target user in target application
    │
    └─► Use: Impersonation token to act as user
```

**Code Implementation:**
```java
public TokenResponse performTokenExchange(String tenant, String requestedSubject, String applicationId) {
    // Step 1: Get impersonation client credentials
    String impersonationClientId = fetchConfigSecrets.fetchProviderSecretsForTenant(
        tenant, PLATFORM_APP_NAME, "clientId", IAM_IMPERSONATION_CLIENT_CONFIG);
    String impersonationClientSecret = fetchConfigSecrets.fetchProviderSecretsForTenant(
        tenant, PLATFORM_APP_NAME, "clientSecret", IAM_IMPERSONATION_CLIENT_CONFIG);
    
    // Step 2: Generate subject token (service account token)
    TokenRequest clientTokenRequest = TokenRequest.builder()
            .grantType(CLIENT_CREDENTIALS)
            .clientId(impersonationClientId)
            .clientSecret(impersonationClientSecret)
            .scope("openid email profile")
            .build();
    
    TokenResponse subjectTokenResponse = getClientToken(tenant, clientTokenRequest);
    
    // Step 3: Prepare exchange request
    ExchangeTokenRequest exchangeRequest = new ExchangeTokenRequest();
    exchangeRequest.setGrantType(TOKEN_EXCHANGE_GRANT_TYPE);
    exchangeRequest.setClientId(impersonationClientId);
    exchangeRequest.setClientSecret(impersonationClientSecret);
    exchangeRequest.setSubjectToken(subjectTokenResponse.getAccessToken());
    exchangeRequest.setRequestedSubject(requestedSubject); // Target user's Keycloak ID
    exchangeRequest.setSubjectTokenType(ACCESS_TOKEN_TYPE);
    exchangeRequest.setRequestedTokenType(ACCESS_TOKEN_TYPE);
    exchangeRequest.setTargetClient(applicationId);
    exchangeRequest.setTokenExchangeRequest(true);
    
    // Step 4: Perform exchange
    return exchangeToken(tenant, subjectTokenResponse.getAccessToken(), exchangeRequest);
}
```

### 2.3 Magic Link Token Flow

```
┌─────────────────────────────────────────────────────────┐
│         Magic Link Token Flow                          │
└─────────────────────────────────────────────────────────┘

User Registration/Signup
    │
    ├─► POST /apexiam/v1/login/magic-link/signup
    │       Body:
    │       {
    │         "email": "user@example.com",
    │         "firstName": "John",
    │         "lastName": "Doe"
    │       }
    │
    ▼
LoginServiceForKeyCloakImpl.generateUserSignUpMagicLink()
    │
    ├─► Resolve: App/Tenant Context
    │       └─► resolveAppTenantFromHost(host)
    │
    ├─► Get: IdProvider
    │       └─► idProviderService.findDefaultProvider()
    │
    ├─► Get: App Config
    │       └─► getAppConfig(idProvider, appName)
    │
    ├─► Create: Registration Request
    │       ├─► Status: PENDING
    │       ├─► Email, Name, App, Tenant
    │       └─► Reference ID (UUID)
    │
    ├─► Build: Magic Link Payload
    │       ├─► referenceId: {regRefId}
    │       ├─► exp: {expiry} (from app config)
    │       └─► Other metadata
    │
    ├─► Generate: Magic Link Token
    │       └─► magicLinkGenerator.generateToken(payload)
    │               └─► Encrypted token with payload
    │
    ├─► Trigger: Workflow
    │       └─► Send email with magic link
    │
    └─► Return: 201 Created

User Clicks Magic Link
    │
    ├─► GET /apexiam/v1/login/magic-link/verify?code={magicLinkCode}
    │
    ▼
LoginServiceForKeyCloakImpl.decodeLinkAndCreateUser()
    │
    ├─► Decrypt: Magic Link Token
    │       └─► magicLinkGenerator.decryptToken(code)
    │
    ├─► Validate: Expiry
    │       └─► validateNotExpired(payload)
    │
    ├─► Find: Registration Request
    │       └─► findByReferenceIdAndTenantIdAndAppId()
    │
    ├─► Resolve: User
    │       ├─► If exists → Return existing user
    │       └─► If not → Create new user
    │               └─► userService.createSelfSignedUser()
    │
    ├─► Perform: Token Exchange
    │       └─► performTokenExchange(tenantId, user.referenceId, appId)
    │               └─► Get token for newly created user
    │
    └─► Return: TokenResponse
            ├─► access_token
            ├─► refresh_token
            └─► page: {landingPage}
```

**Magic Link Payload Structure:**
```java
MagicLinkPayload {
    referenceId: UUID,        // Registration request reference
    exp: Long,                // Expiry timestamp
    tenantId: String,         // Optional: for direct links
    appId: String,            // Optional: for direct links
    userId: String,           // Optional: for existing user links
    page: String              // Optional: landing page
}
```

**Magic Link Generation:**
```java
private String generateMagicLinkToken(MagicLinkPayload payload) {
    String jsonPayload = serializeToJson(payload);
    return magicLinkGenerator.generateToken(jsonPayload);
    // Returns encrypted token containing payload
}
```

---

## 3. Token Exchange Request Format

### 3.1 Exchange Request Parameters

```
┌─────────────────────────────────────────────────────────┐
│         Token Exchange Request Parameters              │
└─────────────────────────────────────────────────────────┘

Required Parameters:
├─► grant_type: "urn:ietf:params:oauth:grant-type:token-exchange"
├─► subject_token: Current access token
├─► subject_token_type: "urn:ietf:params:oauth:token-type:access_token"
├─► requested_token_type: "urn:ietf:params:oauth:token-type:access_token"
├─► client_id: Impersonation client ID
└─► client_secret: Impersonation client secret

Optional Parameters:
├─► requested_subject: Target user ID (for impersonation)
├─► target_client: Target application ID
├─► requested_issuer: Target issuer
└─► audience: Target audience
```

### 3.2 Request Body Construction

**Code Implementation:**
```java
private HttpRequest.BodyPublisher ofFormData(ExchangeTokenRequest request, String actualSubjectToken) {
    Map<String, String> params = new LinkedHashMap<>();
    
    // Required parameters
    params.put(GRANT_TYPE, request.getGrantType());
    params.put(SUBJECT_TOKEN, actualSubjectToken);
    params.put(CLIENT_ID, request.getClientId());
    params.put(CLIENT_SECRET, request.getClientSecret());
    
    // Optional parameters
    if (StringUtils.isNotBlank(request.getRequestedSubject())) {
        params.put(REQUESTED_SUBJECT, request.getRequestedSubject());
    }
    if (StringUtils.isNotBlank(request.getSubjectTokenType())) {
        params.put(SUBJECT_TOKEN_TYPE, request.getSubjectTokenType());
    }
    if (StringUtils.isNotBlank(request.getRequestedTokenType())) {
        params.put(REQUESTED_TOKEN_TYPE, request.getRequestedTokenType());
    }
    if (StringUtils.isNotBlank(request.getTargetClient())) {
        params.put(TARGET_CLIENT_ID, request.getTargetClient());
    }
    params.put(TOKEN_EXCHANGE_REQUEST, String.valueOf(request.isTokenExchangeRequest()));
    
    // URL encode and join
    String form = params.entrySet().stream()
            .map(entry -> URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8) + "=" +
                    URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8))
            .collect(Collectors.joining("&"));
    
    return HttpRequest.BodyPublishers.ofString(form);
}
```

---

## 4. Token Exchange Scenarios

### 4.1 Scenario 1: Cross-Client Token Exchange

```
┌─────────────────────────────────────────────────────────┐
│         Cross-Client Exchange                           │
└─────────────────────────────────────────────────────────┘

User has token for Platform App
    │
    ├─► Needs: Token for Application App
    │
    ├─► Exchange Request:
    │       ├─► Subject Token: Platform token
    │       ├─► Target Client: Application ID
    │       └─► Requested Subject: Same user
    │
    └─► Result: Token for Application App
            ├─► Same user identity
            ├─► Application-specific permissions
            └─► Application-specific claims
```

**Use Case:**
- User logs into platform UI
- User accesses application
- Need application-specific token

### 4.2 Scenario 2: Impersonation Exchange

```
┌─────────────────────────────────────────────────────────┐
│         Impersonation Exchange                          │
└─────────────────────────────────────────────────────────┘

Admin/Service Account
    │
    ├─► Has: Service account token
    │
    ├─► Needs: Token as specific user
    │
    ├─► Exchange Request:
    │       ├─► Subject Token: Service token
    │       ├─► Requested Subject: User's Keycloak ID
    │       ├─► Target Client: Application ID
    │       └─► Token Exchange: true
    │
    └─► Result: User impersonation token
            ├─► User's identity
            ├─► User's permissions
            └─► Application context
```

**Use Case:**
- Admin troubleshooting user issues
- Support team accessing user account
- Automated user operations

### 4.3 Scenario 3: Magic Link Authentication

```
┌─────────────────────────────────────────────────────────┐
│         Magic Link Exchange                            │
└─────────────────────────────────────────────────────────┘

User Registration Flow
    │
    ├─► Step 1: Generate Magic Link
    │       └─► Encrypted token with registration info
    │
    ├─► Step 2: User Clicks Link
    │       └─► Decrypt and validate token
    │
    ├─► Step 3: Create/Find User
    │       └─► Create user if not exists
    │
    ├─► Step 4: Token Exchange
    │       ├─► Subject Token: Service token
    │       ├─► Requested Subject: New user's Keycloak ID
    │       └─► Target Client: Application ID
    │
    └─► Result: User authentication token
            ├─► New user identity
            ├─► Application access
            └─► Landing page redirect
```

**Use Case:**
- Self-service user registration
- Passwordless authentication
- Email verification flow

---

## 5. Token Transformation

### 5.1 Token Normalization

```
┌─────────────────────────────────────────────────────────┐
│         Token Normalization Flow                       │
└─────────────────────────────────────────────────────────┘

Raw Token (from request)
    │
    ├─► Check: Is JWT?
    │       └─► jwtUtility.isJwt(token)
    │
    ├─► If JWT:
    │       ├─► Try: Decode
    │       │       └─► If successful → Return as-is
    │       │
    │       └─► If decode fails:
    │               └─► Treat as encrypted → Decrypt
    │
    └─► If not JWT:
            └─► Decrypt: External provider token
                    ├─► Get: AES key from config
                    ├─► Decrypt: Token
                    ├─► Cache: Decrypted token
                    └─► Return: Decrypted JWT
```

**Code Implementation:**
```java
public String normalizeToken(String token, Tenant tenant, Application application) {
    // Check if JWT
    if (jwtUtility.isJwt(token)) {
        try {
            jwtUtility.getDecodedJwtFromToken(token);
            return token; // Valid JWT, return as-is
        } catch (JWTDecodeException e) {
            log.warn("Token detected as JWT but failed to decode, will attempt decryption.");
        }
    }
    
    // Check cache first
    CacheKeyContext cacheKeyContext = CacheKeyContext.tenantApp(
        tenant.getTenantId(), application.getApplicationId());
    String tokenCacheKey = TOKEN_PREFIX + apexIamUtility.createSHAHash(token);
    String cachedToken = cacheService.get(cacheKeyContext, tokenCacheKey);
    if (cachedToken != null) {
        return cachedToken;
    }
    
    // Decrypt external token
    IdProvider idProvider = idProviderService.findDefaultProvider(tenant);
    if (idProvider == null || !idProvider.isExternalTokenIssuer()) {
        throw new IAMException("Unsupported token format or provider not configured", 401);
    }
    
    return decryptToken(idProvider, application, tokenCacheKey, token, cacheKeyContext);
}
```

### 5.2 Token Decryption

```
┌─────────────────────────────────────────────────────────┐
│         Token Decryption Flow                           │
└─────────────────────────────────────────────────────────┘

Encrypted Token
    │
    ├─► Get: IdProvider Configuration
    │       └─► idProviderService.getSpecificProviderProperties()
    │               └─► Get: AES_KEY property
    │
    ├─► Fetch: AES Key Secret
    │       └─► fetchConfigSecrets.fetchProviderSecrets()
    │               ├─► Provider: IdProvider
    │               ├─► Environment: Application.environment
    │               └─► Secret Key: AES_KEY
    │
    ├─► Decrypt: Token
    │       └─► secureTokenUtil.decryptJwt(token, aesKey)
    │
    ├─► Validate: Decrypted Token
    │       └─► jwtUtility.getDecodedJwtFromToken()
    │
    ├─► Cache: Decrypted Token
    │       ├─► Key: TOKEN_PREFIX + SHA256(encryptedToken)
    │       ├─► Value: Decrypted JWT
    │       └─► TTL: Token expiry duration
    │
    └─► Return: Decrypted JWT Token
```

**Code Implementation:**
```java
public String decryptToken(IdProvider idProvider, Application application, 
                          String tokenCacheKey, String token, CacheKeyContext cacheKeyContext) {
    try {
        // Get AES key configuration
        Map<String, String> config = idProviderService.getSpecificProviderProperties(
            idProvider, List.of(AES_KEY), false);
        String aesKey = fetchConfigSecrets.fetchProviderSecrets(
            idProvider, application.getEnvironment(), config.get(AES_KEY));
        
        // Decrypt token
        token = secureTokenUtil.decryptJwt(token, aesKey);
        
        // Validate decrypted token
        DecodedJWT decodedToken = jwtUtility.getDecodedJwtFromToken(token);
        Duration tokenExpiryDuration = getTokenExpiryDuration(jwtUtility.getTokenExpiry(decodedToken));
        
        // Cache decrypted token
        cacheService.set(cacheKeyContext, tokenCacheKey, token, tokenExpiryDuration);
        
        return token;
    } catch (Exception ex) {
        log.error("Token decryption failed for provider: {}", idProvider.getProviderName(), ex);
        throw new IAMException("Token Decryption Failed", 401);
    }
}
```

---

## 6. Token Exchange Security

### 6.1 Security Considerations

```
┌─────────────────────────────────────────────────────────┐
│         Token Exchange Security                        │
└─────────────────────────────────────────────────────────┘

1. Impersonation Client Security
   ├─► Separate client for impersonation
   ├─► Strong client secret
   ├─► Limited permissions
   └─► Audit logging

2. Subject Token Validation
   ├─► Validate token format
   ├─► Check token expiry
   ├─► Verify token signature
   └─► Validate token claims

3. Requested Subject Validation
   ├─► Verify user exists
   ├─► Check user status (enabled)
   ├─► Validate permissions
   └─► Audit impersonation

4. Target Client Validation
   ├─► Verify client exists
   ├─► Check client permissions
   ├─► Validate client configuration
   └─► Check exchange permissions
```

### 6.2 Impersonation Audit

**Audit Requirements:**
- Log all impersonation exchanges
- Record: Who (admin/service), What (target user), When, Why
- Track: Token usage
- Alert: Unusual patterns

**Implementation:**
```java
// Log impersonation exchange
log.info("Token exchange for impersonation: admin={}, targetUser={}, app={}", 
    adminUserId, requestedSubject, applicationId);
```

---

## 7. Token Exchange Error Handling

### 7.1 Error Scenarios

```
┌─────────────────────────────────────────────────────────┐
│         Token Exchange Errors                          │
└─────────────────────────────────────────────────────────┘

Error Type              │ HTTP Status │ Description
────────────────────────┼─────────────┼─────────────────────────────
Invalid Subject Token   │ 401         │ Subject token invalid/expired
Invalid Client          │ 401         │ Client credentials invalid
User Not Found          │ 404         │ Requested subject not found
User Disabled           │ 403         │ Target user is disabled
Permission Denied       │ 403         │ No permission for exchange
Target Client Invalid   │ 400         │ Target client doesn't exist
Exchange Not Allowed    │ 403         │ Exchange not permitted
```

### 7.2 Error Handling Code

```java
try {
    HttpResponse<String> response = processHttpClient(request, KEY_CLOAK_TOKEN_ENDPOINT);
    
    if (response.statusCode() == 200) {
        return objectMapper.readValue(response.body(), TokenResponse.class);
    } else {
        log.error("Token exchange failed: {} - {}", response.statusCode(), response.body());
        throw new IAMException(SC_BAD_REQUEST, "Token exchange failed", 1001);
    }
} catch (IAMException e) {
    throw e; // Re-throw IAM exceptions
} catch (Exception e) {
    log.error("Error during token exchange", e);
    throw new IAMException(SC_BAD_REQUEST, 1001, "Error while exchanging token", e);
}
```

---

## 8. Token Exchange Caching

### 8.1 Caching Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Exchange Token Caching                        │
└─────────────────────────────────────────────────────────┘

Note: Exchanged tokens are NOT cached
    │
    ├─► Reason: Security
    │       ├─► Impersonation tokens sensitive
    │       ├─► Short-lived tokens
    │       └─► Context-specific
    │
    └─► However: Decrypted tokens ARE cached
            └─► See Token Normalization section
```

**Rationale:**
- Exchanged tokens are context-specific
- Impersonation tokens should not be cached
- Each exchange creates new token
- Caching could lead to security issues

---

## 9. Token Exchange Use Cases

### 9.1 Use Case 1: Admin Impersonation

```
┌─────────────────────────────────────────────────────────┐
│         Admin Impersonation Flow                       │
└─────────────────────────────────────────────────────────┘

Admin User
    │
    ├─► Needs: Debug user issue
    │
    ├─► Call: performTokenExchange()
    │       ├─► Tenant: {tenantId}
    │       ├─► Requested Subject: {userKeycloakId}
    │       └─► Application: {appId}
    │
    ├─► Receive: Impersonation Token
    │
    └─► Use: Token to access as user
            ├─► View user's data
            ├─► Reproduce user's issue
            └─► Test user's permissions
```

### 9.2 Use Case 2: Magic Link Signup

```
┌─────────────────────────────────────────────────────────┐
│         Magic Link Signup Flow                         │
└─────────────────────────────────────────────────────────┘

New User
    │
    ├─► Step 1: Request Signup
    │       └─► POST /magic-link/signup
    │
    ├─► Step 2: Receive Email
    │       └─► Magic link with encrypted token
    │
    ├─► Step 3: Click Link
    │       └─► GET /magic-link/verify?code={token}
    │
    ├─► Step 4: User Created
    │       └─► createSelfSignedUser()
    │
    ├─► Step 5: Token Exchange
    │       └─► performTokenExchange()
    │               └─► Get token for new user
    │
    └─► Step 6: Auto-Login
            └─► Redirect with token
                    └─► User lands on application
```

### 9.3 Use Case 3: Cross-Application Access

```
┌─────────────────────────────────────────────────────────┐
│         Cross-Application Access                       │
└─────────────────────────────────────────────────────────┘

User in Platform App
    │
    ├─► Has: Platform token
    │
    ├─► Accesses: Application App
    │
    ├─► Exchange: Token
    │       ├─► Subject Token: Platform token
    │       ├─► Target Client: Application ID
    │       └─► Requested Subject: Same user
    │
    └─► Receive: Application token
            ├─► Application-specific permissions
            ├─► Application-specific claims
            └─► Application context
```

---

## 10. Token Exchange Best Practices

### 10.1 Security Best Practices

1. **Use Separate Impersonation Client**
   - Don't use regular client for impersonation
   - Strong client secret
   - Limited scope

2. **Audit All Exchanges**
   - Log who, what, when, why
   - Track impersonation usage
   - Alert on anomalies

3. **Validate Permissions**
   - Check admin permissions
   - Verify user status
   - Validate target client

4. **Short-Lived Tokens**
   - Exchanged tokens should be short-lived
   - Don't cache exchanged tokens
   - Revoke when done

### 10.2 Performance Best Practices

1. **Cache Decrypted Tokens**
   - Cache external token decryption
   - Use token expiry as TTL
   - Reduce decryption overhead

2. **Validate Before Exchange**
   - Check token validity
   - Verify user exists
   - Validate permissions early

3. **Error Handling**
   - Fail fast on invalid requests
   - Provide clear error messages
   - Don't expose sensitive info

---

## 11. Token Exchange Summary

### 11.1 Exchange Types

| Exchange Type | Subject Token | Requested Subject | Use Case |
|--------------|---------------|-------------------|----------|
| **Cross-Client** | User token (Client A) | Same user | Access different app |
| **Impersonation** | Service token | Different user | Admin acting as user |
| **Magic Link** | Service token | New/existing user | Self-signup flow |

### 11.2 Exchange Flow Summary

**Standard Flow:**
1. Client has token for context A
2. Client requests exchange for context B
3. IAM validates request
4. IAM calls Keycloak token exchange
5. Keycloak issues new token
6. IAM returns new token to client

**Impersonation Flow:**
1. Admin/service requests impersonation
2. IAM gets service account token
3. IAM exchanges for user token
4. IAM returns impersonation token
5. Admin uses token as user

---

## Summary

**Key Points:**
- Token exchange converts tokens between contexts
- Supports cross-client, impersonation, and magic link flows
- Uses OAuth 2.0 Token Exchange standard
- Keycloak implements exchange protocol
- Security: Audit logging, permission checks
- Performance: Cache decrypted tokens, not exchanged tokens

**Exchange Flow:**
1. Client requests token exchange
2. IAM validates request and extracts subject token
3. IAM calls Keycloak token exchange endpoint
4. Keycloak validates and issues new token
5. IAM returns new token to client

**Next**: Part 5 covers Token Lifecycle Management and Best Practices
