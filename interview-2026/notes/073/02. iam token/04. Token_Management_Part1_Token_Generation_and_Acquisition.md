# Token Management - Part 1: Token Generation and Acquisition

## Overview

This document explains how the Apex IAM system generates and acquires tokens from Keycloak. The system supports multiple OAuth2/OIDC grant types for different authentication scenarios.

---

## 1. Token Types

### 1.1 Token Categories

```
┌─────────────────────────────────────────────────────────┐
│         Token Types in Apex IAM                        │
└─────────────────────────────────────────────────────────┘

1. Access Tokens (JWT)
   ├─► Short-lived (default: 2 hours)
   ├─► Contains user/tenant/app information
   ├─► Used for API authentication
   └─► Signed by Keycloak

2. Refresh Tokens
   ├─► Long-lived (default: 30 days)
   ├─► Used to obtain new access tokens
   ├─► Can be revoked
   └─► Stored securely

3. Service Account Tokens
   ├─► Client credentials grant
   ├─► No user context
   ├─► Used for service-to-service calls
   └─► Cached with grace period

4. Magic Link Tokens
   ├─► Encrypted tokens
   ├─► Time-limited (7 days default)
   ├─► Used for passwordless login
   └─► Contains user/app/tenant info
```

### 1.2 Token Structure (JWT)

```
┌─────────────────────────────────────────────────────────┐
│         JWT Token Structure                            │
└─────────────────────────────────────────────────────────┘

JWT = Header.Payload.Signature

Header:
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "key-id"
}

Payload:
{
  "sub": "user-reference-id",        // Subject (Keycloak user ID)
  "iss": "https://keycloak/realms/tenant-name",  // Issuer
  "aud": "app-id",                    // Audience (Application ID)
  "azp": "app-id",                    // Authorized Party
  "exp": 1234567890,                  // Expiration
  "iat": 1234567890,                  // Issued At
  "tenantId": "tenant-id",            // Custom: Tenant ID
  "roles": ["role1", "role2"],        // User Roles
  "email": "user@example.com",        // User Email
  "preferred_username": "username"    // Username
}

Signature:
RS256(Header + Payload, Private Key)
```

---

## 2. Token Generation Flows

### 2.1 Flow 1: Password Grant (Direct Login)

```
┌─────────────────────────────────────────────────────────┐
│         Password Grant Flow                            │
└─────────────────────────────────────────────────────────┘

Client Application
    │
    ├─► POST /apexiam/v1/login
    │       Body:
    │       {
    │         "tenantId": "jiffy-default",
    │         "username": "john.doe",
    │         "password": "password123",
    │         "clientId": "app-id"
    │       }
    │
    ▼
LoginController.login()
    │
    ▼
LoginServiceForKeyCloakImpl.getToken()
    │
    ├─► Validate: Token Request
    │       ├─► Check: Username not empty
    │       ├─► Check: Password not empty
    │       └─► Check: Client ID not empty
    │
    ├─► Get: Token Endpoint
    │       └─► Well-Known Config
    │           └─► /realms/{tenant}/.well-known/openid-configuration
    │               └─► Extract: token_endpoint
    │
    ├─► Build: HTTP Request
    │       POST /realms/{tenant}/protocol/openid-connect/token
    │       Content-Type: application/x-www-form-urlencoded
    │       Body:
    │       grant_type=password
    │       &client_id={appId}
    │       &username={username}
    │       &password={password}
    │       &scope=openid profile email
    │
    ├─► Send: Request to Keycloak
    │
    ├─► Receive: Token Response
    │       {
    │         "access_token": "eyJhbGc...",
    │         "refresh_token": "eyJhbGc...",
    │         "expires_in": 7200,
    │         "token_type": "Bearer"
    │       }
    │
    ├─► Validate: Token
    │       ├─► Decode: JWT
    │       ├─► Extract: Tenant ID (issuer)
    │       ├─► Extract: App ID (azp)
    │       └─► Validate: Not expired
    │
    ├─► Attach: Token Info (if requested)
    │       └─► getTokenInfo()
    │
    └─► Return: TokenResponse
            {
              "accessToken": "...",
              "refreshToken": "...",
              "expiresIn": 7200,
              "tokenExpiry": 1234567890,
              "tokenInfo": { ... }  // Optional
            }
```

**Code Implementation:**
```java
@Override
public TokenResponse getToken(String tenant, TokenRequest tokenRequest, boolean includeTokenInfo) {
    // Validate request
    validateTokenRequest(tokenRequest);
    
    // Get token endpoint
    String tokenUri = getTokenEndpoint(apexTenant);
    
    // Build request
    HttpRequest request = buildHttpRequest(tokenUri, tokenRequest);
    
    // Send to Keycloak
    HttpResponse<String> response = processHttpClient(request, KEY_CLOAK_TOKEN_ENDPOINT);
    
    // Validate and parse response
    TokenResponse tokenResponse = validateToken(response);
    
    // Attach token info if requested
    if (includeTokenInfo) {
        attachTokenInfo(tokenResponse, tenant, tokenRequest.getClientId(), true);
    }
    
    return tokenResponse;
}
```

### 2.2 Flow 2: Authorization Code Grant (PKCE)

```
┌─────────────────────────────────────────────────────────┐
│         Authorization Code Flow (PKCE)                 │
└─────────────────────────────────────────────────────────┘

Step 1: Generate Authorization URL
    │
    Client
        │
        ├─► GET /apexiam/v1/login/auth-url
        │       Query Params:
        │       - tenantId: "jiffy-default"
        │       - clientId: "app-id"
        │       - redirectUri: "https://app/callback"
        │       - idpHint: "keycloak" (optional)
        │
        ▼
    LoginController.generateAuthUrl()
        │
        ▼
    KeyCloakProvider.generateLoginUrl()
        │
        ├─► Generate: Code Verifier (32 random bytes, Base64URL)
        ├─► Generate: Code Challenge (SHA256(codeVerifier), Base64URL)
        ├─► Generate: State (UUID)
        │
        └─► Build: Authorization URL
                /realms/{tenant}/protocol/openid-connect/auth
                ?response_type=code
                &client_id={appId}
                &redirect_uri={redirectUri}
                &scope=openid profile email
                &state={state}
                &code_challenge={challenge}
                &code_challenge_method=S256
                &kc_idp_hint={idpHint}  // Optional

Step 2: User Authentication
    │
    Client ──► Redirect User to Authorization URL
    │
    User ──► Keycloak Login Page
    │
    User ──► Enters Credentials
    │
    Keycloak ──► Validates Credentials
    │
    Keycloak ──► Redirects to Callback URL
            ?code={authorization_code}
            &state={state}

Step 3: Exchange Code for Token
    │
    Client
        │
        ├─► POST /apexiam/v1/mediated-auth/success
        │       Query Params:
        │       - code: {authorization_code}
        │       - state: {state}
        │       - session_state: {session_state}
        │       - iss: {issuer}
        │
        ▼
    MediatedLoginController.handleSuccess()
        │
        ▼
    KeyCloakProvider.handleSuccessRequest()
        │
        ├─► Build: Token Request
        │       grant_type=authorization_code
        │       &code={code}
        │       &client_id={iamClientId}
        │       &client_secret={iamClientSecret}
        │       &redirect_uri={redirectUri}
        │       &code_verifier={codeVerifier}  // PKCE verification
        │
        ├─► POST: Keycloak Token Endpoint
        │
        └─► Return: TokenResponse
```

**PKCE Implementation:**
```java
public IDPLoginSession generateLoginUrl(String idpHint, String tenantName, String appId) {
    // Generate code verifier (32 random bytes)
    String codeVerifier = generateCodeVerifier();
    
    // Generate code challenge (SHA256 of verifier)
    String codeChallenge = generateCodeChallenge(codeVerifier);
    
    // Generate state
    String state = UUID.randomUUID().toString();
    
    // Build authorization URL
    StringBuilder urlBuilder = new StringBuilder()
            .append(idpConfig.getIdpUrl())
            .append("/realms/").append(tenantName)
            .append("/protocol/openid-connect/auth")
            .append("?response_type=code")
            .append("&client_id=").append(appId)
            .append("&redirect_uri=").append(redirectUri)
            .append("&scope=openid profile email")
            .append("&state=").append(state)
            .append("&code_challenge=").append(codeChallenge)
            .append("&code_challenge_method=S256");
    
    return new IDPLoginSession(url, state, codeVerifier, tenantName, redirectUri, appId);
}
```

### 2.3 Flow 3: Client Credentials Grant (Service Account)

```
┌─────────────────────────────────────────────────────────┐
│         Client Credentials Grant Flow                  │
└─────────────────────────────────────────────────────────┘

Service/Application
    │
    ├─► POST /apexiam/v1/login/token
    │       Body:
    │       {
    │         "grantType": "client_credentials",
    │         "clientId": "service-account-id",
    │         "clientSecret": "service-account-secret",
    │         "scope": "openid email profile"
    │       }
    │
    ▼
LoginServiceForKeyCloakImpl.getToken()
    │
    ├─► Validate: Request
    │       ├─► Check: Scope not empty
    │       └─► Check: Client secret not empty
    │
    ├─► Build: Token Request
    │       POST /realms/{tenant}/protocol/openid-connect/token
    │       Body:
    │       grant_type=client_credentials
    │       &client_id={clientId}
    │       &client_secret={clientSecret}
    │       &scope={scope}
    │
    ├─► Send: Request to Keycloak
    │
    └─► Return: TokenResponse
            {
              "accessToken": "...",
              "expiresIn": 7200
              // No refresh token for client credentials
            }
```

**Service Account Token Caching:**
```java
public String getAccessToken(String tenantName, String clientId, String clientSecret) {
    return localCache.compute(ACCESS_TOKEN_CACHE_KEY, (key, val) -> {
        if (StringUtils.hasText(val)) {
            DecodedJWT decodedToken = jwtUtility.getDecodedJwtFromToken(val);
            Instant expiresAt = decodedToken.getExpiresAt().toInstant();
            Instant expiresAtWithGrace = expiresAt.minusSeconds(graceTimeForTokenExpireInSeconds);
            
            // Check if token is expiring soon
            if (expiresAtWithGrace.isAfter(Instant.now())) {
                return val; // Use cached token
            }
        }
        
        // Fetch new token
        return apexIAMUtility.accessToken(tenantName, clientId, clientSecret);
    });
}
```

---

## 3. Token Request Building

### 3.1 Request Builder

```
┌─────────────────────────────────────────────────────────┐
│         Token Request Building Logic                   │
└─────────────────────────────────────────────────────────┘

buildHttpRequest(tokenUri, tokenRequest)
    │
    ├─► Determine: Grant Type
    │       ├─► password → Username/Password
    │       ├─► authorization_code → Code + Code Verifier
    │       ├─► refresh_token → Refresh Token
    │       └─► client_credentials → Client ID/Secret
    │
    ├─► Build: Form Data
    │       grant_type={grantType}
    │       &client_id={clientId}
    │       &[grant-specific-params]
    │
    └─► Create: HTTP Request
            POST {tokenUri}
            Content-Type: application/x-www-form-urlencoded
            Body: {formData}
```

**Code Implementation:**
```java
private HttpRequest.BodyPublisher ofFormData(TokenRequest tokenRequest) {
    StringBuilder builder = new StringBuilder();
    builder.append("grant_type=").append(tokenRequest.getGrantType())
           .append("&client_id=").append(tokenRequest.getClientId());
    
    switch (tokenRequest.getGrantType()) {
        case CLIENT_CREDENTIALS:
            builder.append("&client_secret=").append(tokenRequest.getClientSecret())
                   .append("&scope=").append(tokenRequest.getScope());
            break;
            
        case GRANT_REFRESH_TOKEN:
            builder.append("&refresh_token=").append(tokenRequest.getRefreshToken());
            break;
            
        default: // authorization_code
            builder.append("&code_verifier=").append(tokenRequest.getCodeVerifier())
                   .append("&redirect_uri=").append(tokenRequest.getRedirectUri())
                   .append("&code=").append(tokenRequest.getCode());
    }
    
    return HttpRequest.BodyPublishers.ofString(builder.toString());
}
```

---

## 4. Token Response Processing

### 4.1 Response Validation

```
┌─────────────────────────────────────────────────────────┐
│         Token Response Validation                      │
└─────────────────────────────────────────────────────────┘

validateToken(HttpResponse response)
    │
    ├─► Check: Status Code = 200
    │       └─► If not 200 → Return null
    │
    ├─► Parse: JSON Response
    │       {
    │         "access_token": "...",
    │         "refresh_token": "...",
    │         "expires_in": 7200,
    │         "token_type": "Bearer"
    │       }
    │
    ├─► Decode: Access Token (JWT)
    │       └─► Extract: Claims
    │
    ├─► Validate: Required Claims
    │       ├─► issuer (tenant name)
    │       ├─► azp (app ID)
    │       └─► exp (expiry)
    │
    ├─► Check: Claims Present
    │       └─► If missing → Return null
    │
    └─► Return: TokenResponse
            {
              "accessToken": "...",
              "refreshToken": "...",
              "expiresIn": 7200,
              "tokenExpiry": 1234567890
            }
```

**Code Implementation:**
```java
private TokenResponse validateToken(HttpResponse<String> res) throws JsonProcessingException {
    if (res.statusCode() == SC_OK) {
        TokenResponse tokenResponse = objectMapper.readValue(res.body(), TokenResponse.class);
        DecodedJWT decodedToken = jwtUtility.getDecodedJwtFromToken(tokenResponse.getAccessToken());
        
        // Extract and validate claims
        String tokenTenantName = jwtUtility.getIssuer(decodedToken);
        String tokenAppId = jwtUtility.getAppId(decodedToken);
        
        if (isEmpty(tokenTenantName) || isEmpty(tokenAppId)) {
            log.error("Invalid token: missing tenant or app ID");
            return null;
        }
        
        // Set token expiry
        tokenResponse.setTokenExpiry(jwtUtility.getTokenExpiry(decodedToken));
        return tokenResponse;
    }
    return null;
}
```

---

## 5. Well-Known Configuration

### 5.1 Configuration Discovery

```
┌─────────────────────────────────────────────────────────┐
│         Well-Known Configuration Flow                  │
└─────────────────────────────────────────────────────────┘

First Request for Tenant
    │
    ▼
getWellKnownConfig(tenantName)
    │
    ├─► Check: In-Memory Cache
    │       └─► wellKnownConfigurationMap.get(tenantName)
    │
    ├─► If Cached: Return cached config
    │
    └─► If Not Cached: Fetch from Keycloak
            │
            ├─► Build: Well-Known URL
            │       {idpUrl}/realms/{tenant}/.well-known/openid-configuration
            │
            ├─► GET: Configuration
            │
            ├─► Parse: JSON Response
            │       {
            │         "authorization_endpoint": "...",
            │         "token_endpoint": "...",
            │         "userinfo_endpoint": "...",
            │         "logout_endpoint": "...",
            │         "jwks_uri": "..."
            │       }
            │
            ├─► Cache: Configuration
            │
            └─► Return: Configuration Map
```

**Cached Endpoints:**
- `authorization_endpoint` → Login URL
- `token_endpoint` → Token exchange URL
- `userinfo_endpoint` → User info URL
- `logout_endpoint` → Logout URL
- `jwks_uri` → Public keys URL

---

## 6. Token Acquisition Summary

### 6.1 Grant Type Comparison

| Grant Type | Use Case | Parameters | Refresh Token | Cached |
|------------|----------|------------|---------------|--------|
| **Password** | Direct login | username, password | Yes | No |
| **Authorization Code** | Web apps (PKCE) | code, code_verifier | Yes | No |
| **Client Credentials** | Service accounts | client_id, secret | No | Yes |
| **Refresh Token** | Token renewal | refresh_token | Yes | No |

### 6.2 Token Acquisition Methods

**1. Direct Login (Password Grant)**
- ✅ Simple and direct
- ✅ No redirect needed
- ❌ Credentials in request
- ❌ Not recommended for web apps

**2. Authorization Code (PKCE)**
- ✅ Secure for web apps
- ✅ No credentials exposed
- ✅ PKCE protection
- ❌ Requires redirect flow

**3. Client Credentials**
- ✅ Service-to-service
- ✅ No user context
- ✅ Cached for performance
- ❌ No user information

---

## 7. Error Handling

### 7.1 Common Errors

```
┌─────────────────────────────────────────────────────────┐
│         Token Acquisition Errors                       │
└─────────────────────────────────────────────────────────┘

1. Invalid Credentials
   ├─► HTTP 401 from Keycloak
   ├─► Error: "invalid_grant"
   └─► Response: IAMException (401, "Invalid credentials")

2. Invalid Client
   ├─► HTTP 401 from Keycloak
   ├─► Error: "invalid_client"
   └─► Response: IAMException (401, "Invalid client")

3. Invalid Grant Type
   ├─► HTTP 400 from Keycloak
   ├─► Error: "unsupported_grant_type"
   └─► Response: IAMException (400, "Unsupported grant type")

4. Network Errors
   ├─► Connection timeout
   ├─► DNS resolution failure
   └─► Response: IAMException (500, "Keycloak connection failed")
```

---

## 8. Best Practices

### 8.1 Security

1. **Never Log Tokens**
   - Tokens contain sensitive information
   - Log only token metadata (expiry, subject)

2. **Use HTTPS**
   - All token requests over HTTPS
   - Prevent token interception

3. **Validate Tokens**
   - Always validate token structure
   - Check required claims
   - Verify expiry

4. **PKCE for Web Apps**
   - Always use PKCE for authorization code flow
   - Prevents code interception attacks

### 8.2 Performance

1. **Cache Well-Known Config**
   - Reduces Keycloak calls
   - Improves response time

2. **Cache Service Tokens**
   - Service account tokens cached
   - Grace period before expiry

3. **Connection Reuse**
   - HTTP client connection pooling
   - Reuse connections to Keycloak

---

## Summary

**Key Points:**
- Multiple grant types supported (password, authorization code, client credentials)
- PKCE implementation for secure web app authentication
- Token validation ensures required claims present
- Well-known configuration cached for performance
- Service account tokens cached with grace period

**Token Acquisition Flow:**
1. Client requests token with credentials/code
2. IAM validates request
3. IAM forwards to Keycloak token endpoint
4. Keycloak validates and issues token
5. IAM validates token structure
6. IAM returns token to client

**Next**: Part 2 covers Token Validation and Decoding
