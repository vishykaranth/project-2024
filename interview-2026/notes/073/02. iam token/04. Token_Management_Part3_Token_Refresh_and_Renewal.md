# Token Management - Part 3: Token Refresh and Renewal

## Overview

This document explains how the Apex IAM system handles token refresh and renewal, including refresh token flows, token expiry management, and automatic token refresh strategies.

---

## 1. Token Refresh Overview

### 1.1 Why Token Refresh?

```
┌─────────────────────────────────────────────────────────┐
│         Token Refresh Rationale                        │
└─────────────────────────────────────────────────────────┘

Access Token Characteristics:
├─► Short-lived (2 hours default)
├─► Contains user permissions
├─► Security: Limited exposure window
└─► Problem: Expires frequently

Refresh Token Characteristics:
├─► Long-lived (30 days default)
├─► Used only for token refresh
├─► Security: Can be revoked
└─► Solution: Renew access tokens without re-authentication

Benefits:
├─► Better user experience (no frequent logins)
├─► Improved security (short-lived access tokens)
├─► Revocable refresh tokens
└─► Seamless token renewal
```

### 1.2 Token Lifecycle

```
┌─────────────────────────────────────────────────────────┐
│         Token Lifecycle                                 │
└─────────────────────────────────────────────────────────┘

Initial Login
    │
    ├─► Access Token (2 hours)
    └─► Refresh Token (30 days)
    │
    ▼
Access Token Expires
    │
    ├─► Use Refresh Token
    └─► Get New Access Token
    │
    ▼
Refresh Token Expires
    │
    └─► User Must Re-authenticate
```

---

## 2. Refresh Token Flow

### 2.1 Standard Refresh Flow

```
┌─────────────────────────────────────────────────────────┐
│         Standard Refresh Token Flow                    │
└─────────────────────────────────────────────────────────┘

Client Application
    │
    ├─► Access Token Expired (or expiring soon)
    │
    ├─► POST /apexiam/v1/login/token
    │       Body:
    │       {
    │         "grantType": "refresh_token",
    │         "clientId": "app-id",
    │         "refreshToken": "eyJhbGc..."
    │       }
    │
    ▼
LoginServiceForKeyCloakImpl.getToken()
    │
    ├─► Validate: Request
    │       ├─► Check: Grant type = refresh_token
    │       ├─► Check: Client ID not empty
    │       └─► Check: Refresh token not empty
    │
    ├─► Get: Token Endpoint
    │       └─► Well-Known Config
    │
    ├─► Build: Refresh Request
    │       POST /realms/{tenant}/protocol/openid-connect/token
    │       Body:
    │       grant_type=refresh_token
    │       &client_id={clientId}
    │       &refresh_token={refreshToken}
    │
    ├─► Send: Request to Keycloak
    │
    ├─► Receive: New Token Response
    │       {
    │         "access_token": "new-access-token",
    │         "refresh_token": "new-refresh-token",  // Optional
    │         "expires_in": 7200
    │       }
    │
    ├─► Validate: New Token
    │       ├─► Decode JWT
    │       ├─► Extract claims
    │       └─► Validate structure
    │
    ├─► Attach: Token Info (if requested)
    │
    └─► Return: TokenResponse
            {
              "accessToken": "new-access-token",
              "refreshToken": "new-refresh-token",
              "expiresIn": 7200,
              "tokenExpiry": 1234567890
            }
```

**Code Implementation:**
```java
@Override
public TokenResponse getToken(String tenant, TokenRequest tokenRequest, boolean includeTokenInfo) {
    Tenant apexTenant = getTenant(tenant);
    
    // Handle refresh token grant
    if (GRANT_REFRESH_TOKEN.equals(tokenRequest.getGrantType())) {
        IdProvider provider = idProviderService.findDefaultProvider(apexTenant);
        
        // Check if external token issuer (SSO)
        if (provider != null && provider.isExternalTokenIssuer()) {
            return refreshExternalToken(tenant, tokenRequest, includeTokenInfo, apexTenant, provider);
        }
    }
    
    // Standard Keycloak refresh
    String tokenUri = getTokenEndpoint(apexTenant);
    HttpRequest request = buildHttpRequest(tokenUri, tokenRequest);
    HttpResponse<String> response = processHttpClient(request, KEY_CLOAK_TOKEN_ENDPOINT);
    TokenResponse tokenResponse = validateToken(response);
    
    if (includeTokenInfo) {
        attachTokenInfo(tokenResponse, tenant, tokenRequest.getClientId(), true);
    }
    
    return tokenResponse;
}
```

---

## 3. External Provider Token Refresh

### 3.1 SSO Token Refresh Flow

```
┌─────────────────────────────────────────────────────────┐
│         External Provider Refresh Flow                │
└─────────────────────────────────────────────────────────┘

refreshExternalToken(tenant, tokenRequest, includeTokenInfo, apexTenant, provider)
    │
    ├─► Get: Application
    │       └─► From clientId in request
    │
    ├─► Normalize: Refresh Token
    │       └─► normalizeToken(refreshToken, tenant, application)
    │           └─► Decrypt if encrypted
    │
    ├─► Refresh: Token with SSO Provider
    │       └─► refreshTokenWithSSO()
    │           │
    │           ├─► Decode: Refresh Token
    │           │       └─► Extract: Username, Expiry
    │           │
    │           ├─► Validate: Token Not Expired
    │           │       └─► If expired → Error
    │           │
    │           ├─► Get: SSO Configuration
    │           │       └─► HOST_URL, REFRESH_TOKEN_URL, API_KEY
    │           │
    │           ├─► Fetch: API Key from Secrets
    │           │       └─► Environment-specific
    │           │
    │           ├─► Call: SSO Refresh Endpoint
    │           │       POST {refreshTokenUrl}
    │           │       Headers:
    │           │       - Authorization: Bearer {apiKey}
    │           │       Body:
    │           │       - refreshToken: {encryptedToken}
    │           │       - username: {username}
    │           │
    │           └─► Receive: New Token Response
    │                   {
    │                     "accessToken": "...",
    │                     "expiresIn": 7200
    │                   }
    │
    ├─► Normalize: New Access Token
    │       └─► Decrypt if needed
    │
    ├─► Decode: New Token
    │       └─► Extract expiry
    │
    ├─► Update: Refresh Token Cache
    │       └─► Cache new refresh token mapping
    │
    ├─► Attach: Token Info
    │
    └─► Return: TokenResponse
```

**Code Implementation:**
```java
public TokenResponse refreshExternalToken(String tenant, TokenRequest tokenRequest, 
                                         boolean includeTokenInfo, Tenant apexTenant, 
                                         IdProvider provider) {
    Application application = applicationRepository.findById(tokenRequest.getClientId())
            .orElseThrow(() -> new SsoTokenRefreshException("Application not found", 401, "", ""));
    
    // Normalize refresh token
    String decryptedAccessToken = normalizeToken(tokenRequest.getRefreshToken(), apexTenant, application);
    
    // Refresh with SSO provider
    TokenResponse tokenResponse = refreshTokenWithSSO(decryptedAccessToken, 
                                                     tokenRequest.getRefreshToken(), 
                                                     provider, application);
    
    // Normalize new access token
    String refreshedToken = tokenResponse.getAccessToken();
    String decryptedRefreshToken = normalizeToken(refreshedToken, apexTenant, application);
    DecodedJWT refreshedJWT = jwtUtility.getDecodedJwtFromToken(decryptedRefreshToken);
    
    // Update refresh token cache
    updateRefreshTokenCache(apexTenant, decryptedRefreshToken, decryptedAccessToken, refreshedJWT);
    
    tokenResponse.setTokenExpiry(jwtUtility.getTokenExpiry(refreshedJWT));
    tokenResponse.setRefreshToken(refreshedToken);
    
    attachTokenInfo(tokenResponse, tenant, tokenRequest.getClientId(), includeTokenInfo);
    return tokenResponse;
}
```

### 3.2 SSO Refresh Implementation

```java
private TokenResponse refreshTokenWithSSO(String token, String encryptedToken, 
                                         IdProvider provider, Application application) {
    try {
        // Decode and validate refresh token
        DecodedJWT decodedJWT = jwtUtility.getDecodedJwtFromToken(token);
        String userName = jwtUtility.getSubject(decodedJWT);
        
        // Check expiry
        if (jwtUtility.isTokenExpired(decodedJWT)) {
            throw new SsoTokenRefreshException("Token is expired", 401, "", "");
        }
        
        // Get SSO configuration
        Map<String, String> config = idProviderService.getSpecificProviderProperties(
                provider, List.of(HOST_URL, REFRESH_TOKEN_URL, API_KEY), false);
        
        if (config == null) {
            throw new SsoTokenRefreshException("SSO config missing", 401, "", "");
        }
        
        // Fetch API key from secrets
        String environment = application.getEnvironment();
        String apiKey = fetchConfigSecrets.fetchProviderSecrets(
                provider, environment, config.get(API_KEY));
        config.put(API_KEY, apiKey);
        
        // Call SSO refresh endpoint
        SSOTokenResponseDto ssoResponse = ssoClient.refreshToken(
                config, encryptedToken, userName);
        
        if (ssoResponse.getCode() == HttpStatus.OK.value() && 
            "OK".equalsIgnoreCase(ssoResponse.getStatus_text())) {
            return TokenResponse.builder()
                    .accessToken(ssoResponse.getData().getAccessToken())
                    .expiresIn(ssoResponse.getData().getExpiresIn())
                    .build();
        } else {
            throw new SsoTokenRefreshException(
                    "SSO Token refresh failed: " + ssoResponse.getMessage(), 401, "", "");
        }
    } catch (Exception e) {
        throw new SsoTokenRefreshException("Failed to refresh token: " + e.getMessage(), 401, "", "");
    }
}
```

---

## 4. Refresh Token Caching

### 4.1 Cache Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Refresh Token Cache Flow                       │
└─────────────────────────────────────────────────────────┘

updateRefreshTokenCache(tenant, refreshedToken, originalToken, decodedToken)
    │
    ├─► Build: Cache Key Context
    │       └─► CacheKeyContext.tenant(tenantId)
    │
    ├─► Build: Original Token Cache Key
    │       └─► buildSSOTokenCacheKey(originalToken, TOKEN_PREFIX)
    │
    ├─► Get: Cached Data for Original Token
    │       └─► cacheService.get(cacheKeyContext, tokenCacheKey)
    │
    ├─► If Cached Data Exists:
    │       ├─► Build: Refresh Token Cache Key
    │       │       └─► buildSSOTokenCacheKey(refreshedToken, TOKEN_PREFIX)
    │       │
    │       ├─► Calculate: Cache Duration
    │       │       └─► Token expiry - current time
    │       │
    │       └─► Cache: Refresh Token Mapping
    │               └─► Cache new token with same data
    │
    └─► Purpose: Enable reverse lookup
            └─► New token → Original token data
```

**Code Implementation:**
```java
private void updateRefreshTokenCache(Tenant apexTenant, String refreshedToken, 
                                    String accessToken, DecodedJWT decodedToken) {
    CacheKeyContext cacheKeyContext = CacheKeyContext.tenant(apexTenant.getTenantId());
    String tokenCacheKey = apexIamUtility.buildSSOTokenCacheKey(accessToken, TOKEN_PREFIX);
    Map<String, String> cacheMap = getCacheMap(cacheKeyContext, tokenCacheKey);
    
    if (!cacheMap.isEmpty()) {
        // Calculate cache duration
        Duration tokenExpiryDuration = getTokenExpiryDuration(jwtUtility.getTokenExpiry(decodedToken));
        
        // Cache refreshed token with same data
        String refreshTokenCacheKey = apexIamUtility.buildSSOTokenCacheKey(refreshedToken, TOKEN_PREFIX);
        cacheService.set(cacheKeyContext, refreshTokenCacheKey, cacheMap, tokenExpiryDuration);
    }
}
```

---

## 5. Token Expiry Management

### 5.1 Expiry Calculation

```
┌─────────────────────────────────────────────────────────┐
│         Token Expiry Management                        │
└─────────────────────────────────────────────────────────┘

getTokenExpiryDuration(expiryEpochSeconds)
    │
    ├─► Get: Current Time
    │       └─► Instant.now()
    │
    ├─► Convert: Expiry to Instant
    │       └─► Instant.ofEpochSecond(expiryEpochSeconds)
    │
    ├─► Calculate: Duration
    │       └─► Duration.between(now, expiry)
    │
    ├─► Check: Negative Duration
    │       └─► If negative → Return Duration.ZERO
    │
    └─► Return: Duration
            └─► Used for cache TTL
```

**Code Implementation:**
```java
public Duration getTokenExpiryDuration(Long expiryEpochSeconds) {
    Instant now = Instant.now();
    Instant expiry = Instant.ofEpochSecond(expiryEpochSeconds);
    
    Duration duration = Duration.between(now, expiry);
    
    // Never return negative duration
    return duration.isNegative() ? Duration.ZERO : duration;
}
```

### 5.2 Remaining Validity

```java
public long getTokenRemainingValidityMillis(DecodedJWT jwt) {
    Long exp = jwt.getClaim(EXP_CLAIM).asLong();
    if (exp == null) {
        return 0L;
    }

    long expiryMillis = exp * 1000; // Convert to milliseconds
    long nowMillis = System.currentTimeMillis();
    long remaining = expiryMillis - nowMillis;
    
    return Math.max(remaining, 0L); // Never negative
}
```

---

## 6. Automatic Token Refresh

### 6.1 Client-Side Refresh Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Client-Side Refresh Strategy                   │
└─────────────────────────────────────────────────────────┘

Client Application
    │
    ├─► Monitor: Access Token Expiry
    │       └─► Check expiry before each API call
    │
    ├─► If Token Expiring Soon (< 5 minutes):
    │       ├─► Call: Refresh Token Endpoint
    │       ├─► Get: New Access Token
    │       └─► Update: Token Storage
    │
    └─► Continue: API Request with New Token
```

**Recommended Refresh Timing:**
- Refresh when token expires in < 5 minutes
- Proactive refresh prevents failed requests
- Background refresh for better UX

### 6.2 Server-Side Token Validation

```
┌─────────────────────────────────────────────────────────┐
│         Server-Side Token Check                        │
└─────────────────────────────────────────────────────────┘

API Request with Token
    │
    ▼
Extract Token
    │
    ▼
Decode Token
    │
    ▼
Check Expiry
    │
    ├─► If Expired:
    │       └─► Return: 401 Unauthorized
    │           └─► Client should refresh token
    │
    └─► If Valid:
            └─► Process Request
```

---

## 7. Refresh Token Rotation

### 7.1 Keycloak Refresh Token Behavior

```
┌─────────────────────────────────────────────────────────┐
│         Refresh Token Rotation                         │
└─────────────────────────────────────────────────────────┘

Keycloak Behavior:
├─► May issue new refresh token on refresh
├─► Old refresh token may be invalidated
└─► Client should use new refresh token

IAM Handling:
├─► Accept new refresh token from Keycloak
├─► Return new refresh token to client
└─► Client should update stored refresh token
```

**Code Implementation:**
```java
// Keycloak may return new refresh token
TokenResponse tokenResponse = validateToken(response);

// If new refresh token provided, use it
if (StringUtils.isNotBlank(tokenResponse.getRefreshToken())) {
    // New refresh token issued
    // Client should update stored refresh token
}

return tokenResponse;
```

---

## 8. Service Account Token Refresh

### 8.1 Cached Token Refresh

```
┌─────────────────────────────────────────────────────────┐
│         Service Account Token Refresh                  │
└─────────────────────────────────────────────────────────┘

TokenManager.getAccessToken(tenantName, clientId, clientSecret)
    │
    ├─► Check: Local Cache
    │       └─► ConcurrentHashMap<String, String>
    │
    ├─► If Cached:
    │       ├─► Decode: Cached Token
    │       ├─► Get: Expiry Time
    │       ├─► Calculate: Expiry with Grace Period
    │       │       └─► expiresAt - graceTimeSeconds
    │       │
    │       ├─► Check: Expiring Soon?
    │       │       └─► If expiresAtWithGrace < now
    │       │
    │       ├─► If Not Expiring:
    │       │       └─► Return: Cached Token
    │       │
    │       └─► If Expiring:
    │               └─► Fetch: New Token
    │
    └─► If Not Cached:
            └─► Fetch: New Token
                    └─► Cache: New Token
                    └─► Return: New Token
```

**Code Implementation:**
```java
public String getAccessToken(String tenantName, String clientId, String clientSecret) {
    return localCache.compute(ACCESS_TOKEN_CACHE_KEY, (key, val) -> {
        if (StringUtils.hasText(val) && jwtUtility.isJwt(jwtUtility.getAccessToken(val))) {
            // Decode cached token
            DecodedJWT decodedToken = jwtUtility.getDecodedJwtFromToken(
                    jwtUtility.getAccessToken(val));
            
            // Calculate expiry with grace period
            Instant expiresAt = decodedToken.getExpiresAt().toInstant();
            Instant expiresAtWithGrace = expiresAt.minusSeconds(graceTimeForTokenExpireInSeconds);
            Instant current = Instant.now();
            
            // Check if expiring soon
            boolean expiring = expiresAtWithGrace.isBefore(current);
            
            if (!expiring) {
                return val; // Use cached token
            }
        }
        
        // Fetch new token
        return apexIAMUtility.accessToken(tenantName, clientId, clientSecret);
    });
}
```

**Grace Period:**
- Default: 300 seconds (5 minutes)
- Configurable: `service-account.graceTimeForTokenExpireInSeconds`
- Purpose: Refresh before expiry to avoid failures

---

## 9. Refresh Token Errors

### 9.1 Error Scenarios

```
┌─────────────────────────────────────────────────────────┐
│         Refresh Token Errors                           │
└─────────────────────────────────────────────────────────┘

1. Invalid Refresh Token
   ├─► HTTP 400 from Keycloak
   ├─► Error: "invalid_grant"
   └─► Response: IAMException (401, "Invalid refresh token")

2. Expired Refresh Token
   ├─► HTTP 400 from Keycloak
   ├─► Error: "invalid_grant"
   └─► Response: IAMException (401, "Refresh token expired")

3. Revoked Refresh Token
   ├─► HTTP 400 from Keycloak
   ├─► Error: "invalid_grant"
   └─► Response: IAMException (401, "Refresh token revoked")

4. Invalid Client
   ├─► HTTP 401 from Keycloak
   ├─► Error: "invalid_client"
   └─► Response: IAMException (401, "Invalid client")

5. SSO Refresh Failure
   ├─► Network error
   ├─► Invalid API key
   └─► Response: SsoTokenRefreshException (401, "SSO refresh failed")
```

### 9.2 Error Handling

```java
try {
    TokenResponse tokenResponse = refreshToken(tokenRequest);
    return tokenResponse;
} catch (SsoTokenRefreshException e) {
    log.error("SSO token refresh failed", e);
    throw e; // Re-throw as-is
} catch (Exception e) {
    log.error("Token refresh failed", e);
    throw new IAMException(401, "Failed to refresh token: " + e.getMessage(), 401);
}
```

---

## 10. Refresh Token Best Practices

### 10.1 Security

1. **Store Refresh Tokens Securely**
   - Use secure storage (encrypted)
   - Never log refresh tokens
   - Use HTTP-only cookies (web apps)

2. **Rotate Refresh Tokens**
   - Accept new refresh tokens
   - Invalidate old refresh tokens
   - Update stored refresh token

3. **Monitor Refresh Token Usage**
   - Log refresh attempts
   - Alert on suspicious activity
   - Revoke compromised tokens

### 10.2 Performance

1. **Proactive Refresh**
   - Refresh before expiry
   - Background refresh for better UX
   - Cache new tokens immediately

2. **Batch Refresh**
   - Refresh multiple tokens together
   - Reduce API calls
   - Improve efficiency

3. **Grace Period**
   - Use grace period for service tokens
   - Avoid last-minute failures
   - Smooth token transitions

---

## 11. Refresh Token Flow Summary

### 11.1 Flow Comparison

| Flow Type | Use Case | Token Source | Refresh Endpoint |
|-----------|----------|--------------|------------------|
| **Standard** | Keycloak tokens | Keycloak refresh token | Keycloak token endpoint |
| **External SSO** | External provider | Encrypted refresh token | SSO provider endpoint |
| **Service Account** | Service-to-service | Cached token | Keycloak (with grace period) |

### 11.2 Refresh Scenarios

**Scenario 1: User Token Refresh**
- User's access token expires
- Client uses refresh token
- New access + refresh token issued
- User continues without re-login

**Scenario 2: Service Token Refresh**
- Service account token expiring
- Automatic refresh with grace period
- Cached token updated
- No service interruption

**Scenario 3: SSO Token Refresh**
- External provider token expires
- Decrypt refresh token
- Call SSO refresh endpoint
- New token issued and cached

---

## Summary

**Key Points:**
- Multiple refresh flows (standard, external SSO, service account)
- Refresh token rotation support
- Caching strategy for performance
- Grace period for service tokens
- Error handling for refresh failures

**Refresh Flow:**
1. Client detects token expiring
2. Client calls refresh endpoint with refresh token
3. IAM validates and forwards to Keycloak/SSO
4. New tokens issued
5. IAM validates and returns to client
6. Client updates stored tokens

**Next**: Part 4 covers Token Exchange and Transformation
