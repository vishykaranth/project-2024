# Token Management - Part 2: Token Validation and Decoding

## Overview

This document explains how the Apex IAM system validates and decodes JWT tokens, including signature verification, claim extraction, and token normalization for external providers.

---

## 1. Token Validation Overview

### 1.1 Validation Layers

```
┌─────────────────────────────────────────────────────────┐
│         Token Validation Layers                        │
└─────────────────────────────────────────────────────────┘

Layer 1: Format Validation
    ├─► JWT Structure Check
    ├─► Base64 Decoding
    └─► JSON Parsing

Layer 2: Claim Validation
    ├─► Required Claims Present
    ├─► Expiry Check
    ├─► Issuer Validation
    └─► Audience Validation

Layer 3: Signature Verification
    ├─► Signature Algorithm
    ├─► Public Key Retrieval
    └─► Signature Verification

Layer 4: Business Logic Validation
    ├─► Tenant Validation
    ├─► Application Validation
    ├─► User Validation
    └─► Permission Check
```

---

## 2. JWT Structure Validation

### 2.1 JWT Format Check

```
┌─────────────────────────────────────────────────────────┐
│         JWT Format Validation                          │
└─────────────────────────────────────────────────────────┘

Token: "eyJhbGc...header...payload...signature"

Step 1: Split Token
    ├─► Split by "."
    ├─► Expected: 3 parts
    └─► If not 3 parts → Invalid JWT

Step 2: Decode Header
    ├─► Base64URL decode part[0]
    ├─► Parse JSON
    ├─► Check: "alg" field present
    └─► Check: "typ" = "JWT" (optional)

Step 3: Decode Payload
    ├─► Base64URL decode part[1]
    └─► Parse JSON

Step 4: Validate Structure
    └─► All parts valid → JWT format valid
```

**Code Implementation:**
```java
public boolean isJwt(String token) {
    if (token == null || token.trim().isEmpty()) {
        return false;
    }

    String[] parts = token.split("\\.");
    if (parts.length != 3) {
        return false; // Not a JWT
    }

    try {
        // Validate Base64URL decoding
        Base64.getUrlDecoder().decode(parts[0]); // Header
        Base64.getUrlDecoder().decode(parts[1]); // Payload

        // Parse header JSON
        String headerJson = new String(Base64.getUrlDecoder().decode(parts[0]));
        JsonNode header = objectMapper.readTree(headerJson);

        // Validate expected fields
        if (!header.has("alg")) {
            return false;
        }

        // Check type (optional)
        String typ = header.has("typ") ? header.get("typ").asText() : null;
        return typ == null || "JWT".equalsIgnoreCase(typ);
    } catch (Exception e) {
        return false; // Invalid Base64 or JSON structure
    }
}
```

---

## 3. Token Decoding

### 3.1 JWT Decoding Process

```
┌─────────────────────────────────────────────────────────┐
│         JWT Decoding Flow                              │
└─────────────────────────────────────────────────────────┘

getDecodedJwtFromToken(token)
    │
    ├─► Strip: Bearer Prefix (if present)
    │       └─► "Bearer eyJhbGc..." → "eyJhbGc..."
    │
    ├─► Decode: JWT (using Auth0 library)
    │       └─► JWT.decode(token)
    │
    └─► Return: DecodedJWT
            ├─► Header (algorithm, type)
            ├─► Payload (claims)
            └─► Signature (for verification)
```

**Code Implementation:**
```java
public String getAccessToken(String token) {
    return StringUtils.replaceOnce(token, BEARER_HEADER_PLACE_HOLDER, StringUtils.EMPTY);
}

public DecodedJWT getDecodedJwtFromToken(String token) {
    return JWT.decode(token); // Decode without verification (fast)
}
```

**Note**: `JWT.decode()` decodes without signature verification. Signature verification is done separately when needed.

---

## 4. Claim Extraction

### 4.1 Standard Claims

```
┌─────────────────────────────────────────────────────────┐
│         Standard JWT Claims                            │
└─────────────────────────────────────────────────────────┘

Standard Claims:
├─► sub (Subject)
│   └─► Keycloak user ID (referenceId)
│
├─► iss (Issuer)
│   └─► Keycloak realm URL
│       └─► Extract tenant name from URL
│
├─► aud (Audience)
│   └─► Application/client ID
│
├─► azp (Authorized Party)
│   └─► Application ID (primary)
│
├─► exp (Expiration)
│   └─► Unix timestamp (seconds)
│
├─► iat (Issued At)
│   └─► Unix timestamp (seconds)
│
└─► roles
    └─► Array of user roles
```

### 4.2 Custom Claims

```
┌─────────────────────────────────────────────────────────┐
│         Custom Claims                                  │
└─────────────────────────────────────────────────────────┘

Custom Claims:
├─► tenantId
│   └─► Tenant identifier
│
├─► target_client
│   └─► Target application (for token exchange)
│
└─► iam_user_id
    └─► Apex IAM user ID
```

### 4.3 Claim Extraction Methods

**Code Implementation:**
```java
// Subject (user ID)
public String getSubject(DecodedJWT jwt) {
    return jwt.getSubject(); // Keycloak user ID
}

// Issuer (tenant name)
public String getIssuer(DecodedJWT jwt) {
    // Extract tenant name from issuer URL
    // "https://keycloak/realms/jiffy-default" → "jiffy-default"
    return StringUtils.substringAfterLast(jwt.getIssuer(), "/");
}

// Application ID
public String getAppId(DecodedJWT jwt) {
    // Check target_client first (for exchanged tokens)
    String targetClientId = jwt.getClaim(TARGET_CLIENT_ID_CLAIM).asString();
    if (StringUtils.isNotBlank(targetClientId)) {
        return targetClientId;
    }
    // Fallback to azp
    return jwt.getClaim(AZP_CLAIM).asString();
}

// Roles
public List<String> getRoles(DecodedJWT jwt) {
    return jwt.getClaim(IAM_ROLES_CLAIM).asList(String.class);
}

// Token Expiry
public Long getTokenExpiry(DecodedJWT jwt) {
    return jwt.getClaim(EXP_CLAIM).asLong();
}

// Token Issued At
public Long getTokenIssuedAt(DecodedJWT jwt) {
    return jwt.getClaim(IAT_CLAIM).asLong();
}
```

---

## 5. Token Expiry Validation

### 5.1 Expiry Check

```
┌─────────────────────────────────────────────────────────┐
│         Token Expiry Validation                        │
└─────────────────────────────────────────────────────────┘

isTokenExpired(DecodedJWT jwt)
    │
    ├─► Extract: Expiry Claim (exp)
    │       └─► Unix timestamp (seconds)
    │
    ├─► Get: Current Time
    │       └─► System.currentTimeMillis() / 1000
    │
    ├─► Compare: Expiry vs Current
    │       └─► If expiry < current → Expired
    │
    └─► Return: Boolean
            ├─► true → Token expired
            └─► false → Token valid
```

**Code Implementation:**
```java
public boolean isTokenExpired(DecodedJWT jwt) {
    Long expiryTime = getTokenExpiry(jwt);
    if (expiryTime == null) {
        return true; // No expiry = invalid
    }
    
    long currentTime = System.currentTimeMillis() / 1000; // Convert to seconds
    return expiryTime < currentTime;
}

public long getTokenRemainingValidityMillis(DecodedJWT jwt) {
    Long exp = jwt.getClaim(EXP_CLAIM).asLong();
    if (exp == null) {
        return 0L;
    }

    long expiryMillis = exp * 1000; // Convert to milliseconds
    long nowMillis = System.currentTimeMillis();
    long remaining = expiryMillis - nowMillis;
    
    return Math.max(remaining, 0L); // Never negative
}
```

### 5.2 Expiry Validation in Request Flow

```
┌─────────────────────────────────────────────────────────┐
│         Expiry Check in Request Processing             │
└─────────────────────────────────────────────────────────┘

Request with Token
    │
    ▼
Extract Token from Header
    │
    ▼
Decode Token
    │
    ▼
Check Expiry
    │
    ├─► If Expired:
    │       └─► Throw: IAMException (401, "Token Expired")
    │
    └─► If Valid:
            └─► Continue Processing
```

---

## 6. Token Normalization

### 6.1 Normalization Flow

```
┌─────────────────────────────────────────────────────────┐
│         Token Normalization Flow                      │
└─────────────────────────────────────────────────────────┘

normalizeToken(token, tenant, application)
    │
    ├─► Check: Is JWT?
    │       ├─► YES → Try Decode
    │       │       ├─► Success → Return token (already JWT)
    │       │       └─► Fail → Continue to decryption
    │       │
    │       └─► NO → Continue to decryption
    │
    ├─► Check: Cache
    │       ├─► Build: Cache Key
    │       │       └─► TOKEN_PREFIX + SHA256(token)
    │       │
    │       ├─► Lookup: Cache
    │       │
    │       └─► If Found: Return cached token
    │
    └─► Decrypt: Token (External Provider)
            │
            ├─► Get: IdProvider
            │       └─► Find default provider for tenant
            │
            ├─► Check: External Token Issuer?
            │       └─► If not → Error
            │
            ├─► Get: AES Key from Config
            │       └─► Fetch from secrets manager
            │
            ├─► Decrypt: Token
            │       └─► AES-GCM decryption
            │
            ├─► Validate: Decrypted is JWT
            │
            ├─► Cache: Decrypted token
            │       └─► Cache with token expiry duration
            │
            └─► Return: Decrypted JWT token
```

**Code Implementation:**
```java
public String normalizeToken(String token, Tenant tenant, Application application) {
    // Check if already a valid JWT
    if (jwtUtility.isJwt(token)) {
        try {
            jwtUtility.getDecodedJwtFromToken(token);
            return token; // Already a valid JWT
        } catch (JWTDecodeException e) {
            log.warn("Token detected as JWT but failed to decode, will attempt decryption.");
        }
    }

    // Check cache
    CacheKeyContext cacheKeyContext = CacheKeyContext.tenantApp(
            tenant.getTenantId(), 
            application.getApplicationId());
    String tokenCacheKey = TOKEN_PREFIX + apexIamUtility.createSHAHash(token);
    String cachedToken = cacheService.get(cacheKeyContext, tokenCacheKey);
    
    if (cachedToken != null) {
        return cachedToken; // Return cached decrypted token
    }

    // Decrypt token (external provider)
    IdProvider idProvider = idProviderService.findDefaultProvider(tenant);
    if (idProvider == null || !idProvider.isExternalTokenIssuer()) {
        throw new IAMException(401, "Unsupported token format or provider not configured", 401);
    }
    
    return decryptToken(idProvider, application, tokenCacheKey, token, cacheKeyContext);
}
```

---

## 7. Token Decryption (External Providers)

### 7.1 Decryption Flow

```
┌─────────────────────────────────────────────────────────┐
│         Token Decryption Flow                          │
└─────────────────────────────────────────────────────────┘

decryptToken(idProvider, application, tokenCacheKey, token, cacheKeyContext)
    │
    ├─► Get: Provider Configuration
    │       └─► idProviderService.getSpecificProviderProperties()
    │           └─► Properties: [AES_KEY]
    │
    ├─► Fetch: AES Key from Secrets
    │       └─► fetchConfigSecrets.fetchProviderSecrets()
    │           └─► Environment-specific secret
    │
    ├─► Decrypt: Token
    │       └─► SecureTokenUtil.decryptJwt()
    │           ├─► AES-GCM decryption
    │           └─► Validate decrypted is JWT
    │
    ├─► Decode: Decrypted JWT
    │       └─► Extract expiry for caching
    │
    ├─► Calculate: Cache Duration
    │       └─► Token expiry - current time
    │
    ├─► Cache: Decrypted Token
    │       └─► Cache with expiry duration
    │
    └─► Return: Decrypted JWT Token
```

**AES-GCM Decryption:**
```java
public String decryptJwt(String token, String base64AesKey) {
    String decrypted = decrypt(token, base64AesKey);
    
    // Validate decrypted is a JWT
    if (!jwtUtility.isJwt(decrypted)) {
        throw new IAMException(401, "Decrypted token is not a valid JWT", 401);
    }
    
    return decrypted;
}

private static String decrypt(String base64Token, String base64AesKey) {
    // Decode AES key
    byte[] aesKey = Base64.getDecoder().decode(base64AesKey);
    validateAesKeyLength(aesKey); // 16, 24, or 32 bytes
    
    // Decode token
    byte[] decoded = Base64.getDecoder().decode(base64Token);
    ByteArrayInputStream bais = new ByteArrayInputStream(decoded);
    
    // Read header (1 byte)
    int header = bais.read();
    if (header != TOKEN_HEADER) {
        throw new IllegalArgumentException("Unexpected token header");
    }
    
    // Read IV (12 bytes for GCM)
    byte[] iv = new byte[GCM_IV_LENGTH];
    bais.read(iv);
    
    // Read encrypted data
    byte[] encryptedBytes = bais.readAllBytes();
    
    // Decrypt using AES-GCM
    Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
    cipher.init(Cipher.DECRYPT_MODE, 
                new SecretKeySpec(aesKey, "AES"), 
                new GCMParameterSpec(GCM_TAG_LENGTH, iv));
    
    return new String(cipher.doFinal(encryptedBytes), StandardCharsets.UTF_8);
}
```

---

## 8. Signature Verification

### 8.1 Signature Verification Flow

```
┌─────────────────────────────────────────────────────────┐
│         Signature Verification Flow                    │
└─────────────────────────────────────────────────────────┘

verifySignature(idProvider, application, token)
    │
    ├─► Get: Provider Configuration
    │       └─► Properties: [RSA_KEY]
    │
    ├─► Fetch: RSA Public Key from Secrets
    │       └─► fetchConfigSecrets.fetchProviderSecrets()
    │           └─► Environment-specific key
    │
    ├─► Extract: Public Key from XML
    │       └─► Parse XML, extract Modulus and Exponent
    │
    ├─► Build: RSAPublicKey
    │       └─► From Modulus and Exponent
    │
    ├─► Create: JWT Verifier
    │       └─► Algorithm: RSA256
    │
    ├─► Verify: Token Signature
    │       └─► If invalid → JWTVerificationException
    │
    └─► Return: Verification Result
```

**Code Implementation:**
```java
public void verifySignature(IdProvider idProvider, Application application, String token) {
    try {
        // Get RSA key from provider configuration
        Map<String, String> config = idProviderService.getSpecificProviderProperties(
                idProvider, List.of(RSA_KEY), false);
        String rsaKey = fetchConfigSecrets.fetchProviderSecrets(
                idProvider, application.getEnvironment(), config.get(RSA_KEY));

        // Extract public key from XML
        RSAPublicKey publicKey = extractPublicKeyFromXml(rsaKey);

        // Create verifier
        Algorithm algorithm = Algorithm.RSA256(publicKey, null);
        JWTVerifier verifier = JWT.require(algorithm).build();
        
        // Verify signature (throws exception if invalid)
        verifier.verify(token);
    } catch (Exception ex) {
        log.error("Token signature verification failed", ex);
        throw new IAMException(401, "Invalid token signature", 401);
    }
}

private RSAPublicKey extractPublicKeyFromXml(String rsaKeyXml) {
    // Parse XML
    Document doc = parseXML(rsaKeyXml);
    
    // Extract Modulus and Exponent
    String modulusBase64 = doc.getElementsByTagName("Modulus").item(0).getTextContent();
    String exponentBase64 = doc.getElementsByTagName("Exponent").item(0).getTextContent();
    
    // Decode and create key spec
    BigInteger modulus = new BigInteger(1, Base64.getDecoder().decode(modulusBase64));
    BigInteger exponent = new BigInteger(1, Base64.getDecoder().decode(exponentBase64));
    
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, exponent);
    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
    
    return (RSAPublicKey) keyFactory.generatePublic(keySpec);
}
```

---

## 9. Request Context Resolution

### 9.1 Context Resolution Flow

```
┌─────────────────────────────────────────────────────────┐
│         Request Context Resolution                     │
└─────────────────────────────────────────────────────────┘

resolveRequestContext(request, rawToken, tenant, application)
    │
    ├─► Extract: Access Token
    │       └─► jwtUtility.getAccessToken(rawToken)
    │
    ├─► Resolve: Tenant & Application
    │       ├─► If provided → Use directly
    │       └─► If not → Extract from token
    │               ├─► Tenant: issuer claim
    │               └─► Application: azp claim
    │
    ├─► Normalize: Token
    │       └─► normalizeToken(accessToken, tenant, application)
    │
    ├─► Decode: Token
    │       └─► jwtUtility.getDecodedJwtFromToken(accessToken)
    │
    ├─► Extract: Headers
    │       └─► Include access token in headers map
    │
    ├─► Validate: Token Expiry
    │       └─► If expired → Throw exception
    │
    ├─► Get: IdProvider
    │       └─► idProviderService.getIdProviderFromToken()
    │
    ├─► Validate & Fetch: User
    │       └─► validateAndFetchUser()
    │
    └─► Build: RequestContext
            ├─► Tenant
            ├─► Application
            ├─► User
            ├─► IdProvider
            ├─► Access Token
            ├─► Decoded JWT
            ├─► Token Expiry
            ├─► Cache Key Context
            └─► Headers
```

**RequestContext Structure:**
```java
public record RequestContext(
    Tenant tenant,
    Application application,
    IdProvider idProvider,
    ApexUser user,
    String accessToken,
    DecodedJWT decodedJWT,
    Long tokenExpiry,
    Duration tokenExpiryDuration,
    Map<String, String> headers,
    String tenantId,
    String applicationId,
    String userId,
    CacheKeyParts cacheKeyParts,
    String tokenHash,
    Long iat
) {}
```

---

## 10. User Validation from Token

### 10.1 User Fetching Flow

```
┌─────────────────────────────────────────────────────────┐
│         User Fetching from Token                       │
└─────────────────────────────────────────────────────────┘

fetchUserFromToken(decodedToken, tenant, provider)
    │
    ├─► Determine: User Claim Type
    │       └─► From provider configuration
    │           ├─► USER_REFERENCE_ID (default)
    │           ├─► USER_EMAIL
    │           ├─► USER_ID
    │           └─► USER_NAME
    │
    ├─► Extract: User Claim from Token
    │       └─► jwtUtility.getClaimFromJwt(decodedToken, claimType)
    │
    ├─► Fetch: User Based on Claim Type
    │       ├─► USER_REFERENCE_ID → findUserByReferenceId()
    │       ├─► USER_EMAIL → checkUserExistsForTenant()
    │       ├─► USER_ID → findUserById()
    │       └─► USER_NAME → findUserByUsernameAndProvider()
    │
    └─► Return: ApexUser (or null if not found)
```

**Code Implementation:**
```java
public ApexUser fetchUserFromToken(DecodedJWT decodedToken, Tenant tenant, IdProvider provider) {
    // Determine user claim type
    UserClaimType userClaimType = getUserClaimType(provider);
    
    // Extract claim from token
    String tokenUserClaim = jwtUtility.getClaimFromJwt(decodedToken, userClaimType);
    
    if (StringUtils.isBlank(tokenUserClaim)) {
        log.error("Token user claim is null");
        return null;
    }
    
    // Fetch user based on claim type
    return switch (userClaimType.getClaimKey()) {
        case USER_REFERENCE_ID -> apexIamUtility.findUserByReferenceId(tokenUserClaim);
        case USER_EMAIL -> apexIamUtility.checkUserExistsForTenant(
                tokenUserClaim, tenant.getTenantId(), provider.getProviderId());
        case USER_ID -> apexIamUtility.findUserById(tokenUserClaim);
        case USER_NAME, JWT_USER_CLAIM -> apexIamUtility.findUserByUsernameAndProvider(
                tenant.getTenantId(), tokenUserClaim, provider.getProviderId());
        default -> null;
    };
}
```

---

## 11. Token Validation in Authorization

### 11.1 ExtAuthz Service Flow

```
┌─────────────────────────────────────────────────────────┐
│         External Authorization Flow                   │
└─────────────────────────────────────────────────────────┘

ExtAuthzService.check()
    │
    ├─► Extract: Token from Request
    │       └─► Authorization header
    │
    ├─► Normalize: Token
    │       └─► normalizeToken(accessToken, tenant, app)
    │
    ├─► Check: Token Invalidated?
    │       └─► isTokenInvalidated(accessToken)
    │           └─► Check cache for TOKEN_STATUS_INVALID
    │
    ├─► Decode: Token
    │       └─► jwtUtility.getDecodedJwtFromToken()
    │
    ├─► Validate: Expiry
    │       └─► If expired → Deny (401)
    │
    ├─► Resolve: Request Context
    │       └─► resolveRequestContext()
    │
    ├─► Check: User Disabled?
    │       └─► If disabled → Deny (403)
    │
    ├─► Get: User Permissions
    │       └─► From cache or database
    │
    ├─► Check: Permission
    │       └─► Permission trie or list check
    │
    └─► Return: Authorization Result
            ├─► ALLOW → 200 OK
            └─► DENY → 403 Forbidden
```

---

## 12. Token Caching Strategy

### 12.1 Cache Keys

```
┌─────────────────────────────────────────────────────────┐
│         Token Cache Strategy                           │
└─────────────────────────────────────────────────────────┘

Cache Keys:
├─► Decrypted Token Cache
│   └─► Key: TOKEN_PREFIX + SHA256(encryptedToken)
│   └─► Value: Decrypted JWT token
│   └─► TTL: Token expiry duration
│
├─► Token Status Cache
│   └─► Key: TOKEN_PREFIX + SHA256(token)
│   └─► Value: { "status": "invalid" }
│   └──► TTL: Token remaining validity
│
└─► SSO Token Cache
    └─► Key: TOKEN_PREFIX + SHA256(token)
    └─► Value: { "firstLogin": "true" }
    └─► TTL: Token expiry duration
```

### 12.2 Cache Benefits

1. **Performance**
   - Avoid repeated decryption
   - Fast token lookup
   - Reduced Keycloak calls

2. **Cost**
   - Reduced encryption/decryption operations
   - Lower CPU usage

3. **Consistency**
   - Same token returns same decrypted value
   - Consistent validation results

---

## 13. Error Handling

### 13.1 Validation Errors

```
┌─────────────────────────────────────────────────────────┐
│         Token Validation Errors                        │
└─────────────────────────────────────────────────────────┘

1. Invalid JWT Format
   ├─► Not 3 parts
   ├─► Invalid Base64
   └─► Response: IAMException (401, "Invalid token format")

2. Token Expired
   ├─► exp < current time
   └─► Response: IAMException (401, "Token Expired")

3. Missing Required Claims
   ├─► No issuer
   ├─► No app ID
   └─► Response: IAMException (401, "Invalid token: missing claims")

4. Invalid Signature
   ├─► Signature verification fails
   └─► Response: IAMException (401, "Invalid token signature")

5. Decryption Failure
   ├─► Invalid AES key
   ├─► Invalid encrypted format
   └─► Response: IAMException (401, "Token decryption failed")

6. User Not Found
   ├─► User claim not found in database
   └─► Response: IAMException (404, "User not found")
```

---

## 14. Best Practices

### 14.1 Validation Best Practices

1. **Always Validate Expiry**
   - Check expiry before processing
   - Fail fast on expired tokens

2. **Cache Decrypted Tokens**
   - Avoid repeated decryption
   - Use token expiry as cache TTL

3. **Validate Required Claims**
   - Ensure tenant, app, user present
   - Fail if critical claims missing

4. **Handle External Tokens**
   - Decrypt before validation
   - Verify signature for external providers

5. **Log Validation Failures**
   - Log validation errors
   - Don't log token values

---

## Summary

**Key Points:**
- Multi-layer validation (format, claims, signature, business logic)
- JWT structure validation before processing
- Claim extraction for tenant, app, user identification
- Token normalization for external encrypted tokens
- Signature verification for external providers
- Caching strategy for performance

**Validation Flow:**
1. Check JWT format
2. Decode token
3. Extract and validate claims
4. Check expiry
5. Normalize (decrypt if needed)
6. Verify signature (if external)
7. Fetch and validate user
8. Build request context

**Next**: Part 3 covers Token Refresh and Renewal Flows
