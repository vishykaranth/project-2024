# Low-Level Design: Amazon Locker - In-Depth Summary

## 1. Requirements Gathering

### Functional Requirements
- Users can select a locker location for delivery
- Users can receive packages in lockers
- Users can retrieve packages using a code
- Delivery personnel can deposit packages into lockers
- System can assign available lockers automatically
- Users can track locker status
- System can send notifications (delivery, pickup reminders)

### Non-Functional Requirements
- High availability (99.9%)
- Low latency (< 100ms for locker assignment)
- Scalability (thousands of lockers, millions of users)
- Security (prevent unauthorized access)
- Reliability (don't lose packages)
- Real-time status updates

### Capacity Estimation
- 10M users
- 100K locker locations
- 1M lockers total
- 5M packages/day
- Peak: 50K packages/hour during holidays

## 2. System Overview

```
┌─────────────────────────────────────────────────────────┐
│              Amazon Locker System                       │
└─────────────────────────────────────────────────────────┘

                    [Users]
                       │
                       ▼
              ┌────────────────┐
              │  Mobile App /   │
              │   Web Portal   │
              └────────┬───────┘
                       │
              ┌────────┴────────┐
              │                 │
              ▼                 ▼
        [Locker Service]  [Notification Service]
              │                 │
              └────────┬────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
        ▼              ▼              ▼
   [Database]    [Cache Layer]  [Locker Hardware]
        │              │              │
        └──────────────┼──────────────┘
                       │
              ┌────────┴────────┐
              │                 │
              ▼                 ▼
        [Message Queue]   [Payment Service]
```

## 3. Core Entities & Classes

### 3.1 Class Diagram

```
┌─────────────────────────────────────────────────────────┐
│              Class Diagram                              │
└─────────────────────────────────────────────────────────┘

┌─────────────────────┐
│      User           │
├─────────────────────┤
│ - userId: String    │
│ - email: String     │
│ - phone: String     │
│ - name: String      │
└─────────────────────┘
         │
         │ 1
         │
         │ *
         ▼
┌─────────────────────┐
│     Package         │
├─────────────────────┤
│ - packageId: String │
│ - orderId: String   │
│ - userId: String    │
│ - size: Size        │
│ - weight: double    │
│ - status: Status    │
└─────────────────────┘
         │
         │ 1
         │
         │ 1
         ▼
┌─────────────────────┐
│     Locker          │
├─────────────────────┤
│ - lockerId: String  │
│ - locationId: String│
│ - size: Size        │
│ - status: Status    │
│ - accessCode: String│
│ - packageId: String │
│ - reservedUntil: Date│
└─────────────────────┘
         │
         │ *
         │
         │ 1
         ▼
┌─────────────────────┐
│    LockerLocation    │
├─────────────────────┤
│ - locationId: String│
│ - address: Address   │
│ - coordinates: Geo   │
│ - totalLockers: int  │
│ - availableLockers: int│
└─────────────────────┘
```

### 3.2 Enums

```java
public enum LockerSize {
    SMALL,    // 10" x 10" x 10"
    MEDIUM,   // 12" x 12" x 12"
    LARGE     // 18" x 18" x 18"
}

public enum LockerStatus {
    AVAILABLE,
    RESERVED,
    OCCUPIED,
    OUT_OF_SERVICE
}

public enum PackageStatus {
    IN_TRANSIT,
    DELIVERED_TO_LOCKER,
    PICKED_UP,
    EXPIRED
}
```

## 4. Database Schema

### 4.1 Tables

```
┌─────────────────────────────────────────────────────────┐
│              Database Schema                            │
└─────────────────────────────────────────────────────────┘

Users Table:
├─ user_id (PK, UUID)
├─ email (UNIQUE)
├─ phone
├─ name
└─ created_at

LockerLocations Table:
├─ location_id (PK, UUID)
├─ address
├─ city
├─ state
├─ zip_code
├─ latitude
├─ longitude
├─ total_lockers
└─ created_at

Lockers Table:
├─ locker_id (PK, UUID)
├─ location_id (FK)
├─ locker_number (e.g., A-1, A-2)
├─ size (SMALL/MEDIUM/LARGE)
├─ status (AVAILABLE/RESERVED/OCCUPIED/OUT_OF_SERVICE)
├─ package_id (FK, nullable)
├─ reserved_until (nullable)
└─ last_updated

Packages Table:
├─ package_id (PK, UUID)
├─ order_id
├─ user_id (FK)
├─ locker_id (FK, nullable)
├─ size (SMALL/MEDIUM/LARGE)
├─ weight
├─ status (IN_TRANSIT/DELIVERED/PICKED_UP/EXPIRED)
├─ delivery_code (6-digit code)
├─ pickup_code (6-digit code)
├─ delivered_at (nullable)
├─ picked_up_at (nullable)
├─ expires_at
└─ created_at

LockerReservations Table:
├─ reservation_id (PK, UUID)
├─ package_id (FK)
├─ locker_id (FK)
├─ user_id (FK)
├─ reserved_at
├─ expires_at
└─ status (ACTIVE/COMPLETED/EXPIRED)
```

### 4.2 Indexes

```sql
-- Fast lookup by location
CREATE INDEX idx_lockers_location ON lockers(location_id);
CREATE INDEX idx_lockers_status ON lockers(status);

-- Fast package lookup
CREATE INDEX idx_packages_user ON packages(user_id);
CREATE INDEX idx_packages_locker ON packages(locker_id);
CREATE INDEX idx_packages_status ON packages(status);
CREATE INDEX idx_packages_delivery_code ON packages(delivery_code);
CREATE INDEX idx_packages_pickup_code ON packages(pickup_code);

-- Location search
CREATE INDEX idx_locations_coordinates ON locker_locations(latitude, longitude);
```

## 5. Core Workflows

### 5.1 Package Delivery Flow

```
┌─────────────────────────────────────────────────────────┐
│         Package Delivery Flow                           │
└─────────────────────────────────────────────────────────┘

1. User places order and selects locker delivery
   │
   ▼
2. System creates package record
   ├─ Generate delivery_code (6 digits)
   ├─ Generate pickup_code (6 digits)
   └─ Set status: IN_TRANSIT
   │
   ▼
3. Package shipped to locker location
   │
   ▼
4. Delivery person arrives at locker
   │
   ▼
5. Delivery person enters delivery_code
   │
   ▼
6. System validates code
   ├─ Check if code exists
   ├─ Check if package already delivered
   └─ Check if code expired
   │
   ├─ Invalid → Return error
   │
   └─ Valid → Proceed
       │
       ▼
7. System finds available locker
   ├─ Match package size to locker size
   ├─ Check locker availability
   └─ Reserve locker
   │
   ▼
8. Open locker door
   │
   ▼
9. Delivery person places package
   │
   ▼
10. Close locker door
    │
    ▼
11. System updates status
    ├─ Mark locker as OCCUPIED
    ├─ Update package status: DELIVERED
    ├─ Set delivered_at timestamp
    └─ Set expires_at (3 days)
    │
    ▼
12. Send notification to user
    ├─ Package delivered
    ├─ Locker location
    ├─ Pickup code
    └─ Expiration date
```

### 5.2 Package Pickup Flow

```
┌─────────────────────────────────────────────────────────┐
│         Package Pickup Flow                            │
└─────────────────────────────────────────────────────────┘

1. User arrives at locker location
   │
   ▼
2. User opens app and selects "Pickup Package"
   │
   ▼
3. System shows user's packages at location
   │
   ▼
4. User selects package to pickup
   │
   ▼
5. User enters pickup_code (or app auto-fills)
   │
   ▼
6. System validates code
   ├─ Check if code matches package
   ├─ Check if package exists
   ├─ Check if package expired
   └─ Check if already picked up
   │
   ├─ Invalid → Return error
   │
   └─ Valid → Proceed
       │
       ▼
7. System opens locker door
   │
   ▼
8. User retrieves package
   │
   ▼
9. User closes locker door
   │
   ▼
10. System updates status
    ├─ Mark locker as AVAILABLE
    ├─ Update package status: PICKED_UP
    ├─ Set picked_up_at timestamp
    └─ Clear package_id from locker
    │
    ▼
11. Send confirmation to user
```

### 5.3 Locker Assignment Algorithm

```java
public class LockerAssignmentService {
    
    public Locker assignLocker(Package package, String locationId) {
        // 1. Get all available lockers at location
        List<Locker> availableLockers = lockerRepository
            .findByLocationAndStatus(locationId, LockerStatus.AVAILABLE);
        
        // 2. Filter by size compatibility
        List<Locker> compatibleLockers = availableLockers.stream()
            .filter(locker -> isSizeCompatible(locker.getSize(), package.getSize()))
            .collect(Collectors.toList());
        
        if (compatibleLockers.isEmpty()) {
            throw new NoAvailableLockerException("No compatible lockers available");
        }
        
        // 3. Select best locker (prefer exact size match)
        Locker selectedLocker = compatibleLockers.stream()
            .min(Comparator
                .comparing((Locker l) -> l.getSize() != package.getSize())
                .thenComparing(Locker::getLockerNumber))
            .orElseThrow();
        
        // 4. Reserve locker
        selectedLocker.setStatus(LockerStatus.RESERVED);
        selectedLocker.setReservedUntil(now().plusMinutes(15));
        lockerRepository.save(selectedLocker);
        
        return selectedLocker;
    }
    
    private boolean isSizeCompatible(LockerSize lockerSize, LockerSize packageSize) {
        // Locker must be at least as large as package
        return lockerSize.ordinal() >= packageSize.ordinal();
    }
}
```

## 6. Sequence Diagrams

### 6.1 Delivery Sequence

```
┌─────────────────────────────────────────────────────────┐
│         Delivery Sequence Diagram                      │
└─────────────────────────────────────────────────────────┘

Delivery Person    Locker Hardware    Locker Service    Database
      │                   │                  │              │
      │──Enter Code──────>│                  │              │
      │                   │──Validate───────>│              │
      │                   │                  │──Check───────>│
      │                   │                  │<--Valid───────│
      │                   │                  │              │
      │                   │                  │──Find Locker─>│
      │                   │                  │<--Locker──────│
      │                   │                  │              │
      │                   │<--Open Door──────│              │
      │<--Door Opens──────│                  │              │
      │                   │                  │              │
      │──Place Package────>│                  │              │
      │                   │                  │              │
      │──Close Door───────>│                  │              │
      │                   │──Confirm────────>│              │
      │                   │                  │──Update──────>│
      │                   │                  │<--Success─────│
      │                   │<--Success────────│              │
      │<--Success──────────│                  │              │
```

### 6.2 Pickup Sequence

```
┌─────────────────────────────────────────────────────────┐
│         Pickup Sequence Diagram                        │
└─────────────────────────────────────────────────────────┘

User          Mobile App      Locker Service    Database    Notification
  │                │                 │              │            │
  │──Pickup───────>│                 │              │            │
  │                │──Enter Code────>│              │            │
  │                │                 │──Validate───>│            │
  │                │                 │<--Valid──────│            │
  │                │                 │              │            │
  │                │                 │──Open───────>│            │
  │                │<--Open Door─────│              │            │
  │<--Door Opens───│                 │              │            │
  │                │                 │              │            │
  │──Retrieve──────>│                 │              │            │
  │                │                 │              │            │
  │──Close Door────>│                 │              │            │
  │                │──Confirm────────>│              │            │
  │                │                 │──Update──────>│            │
  │                │                 │<--Success─────│            │
  │                │                 │              │            │
  │                │                 │──Notify───────────────>│
  │                │<--Success───────│              │            │
  │<--Success───────│                 │              │            │
```

## 7. Code Implementation

### 7.1 Locker Service

```java
@Service
public class LockerService {
    
    @Autowired
    private LockerRepository lockerRepository;
    
    @Autowired
    private PackageRepository packageRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    @Transactional
    public Locker assignLocker(Package package, String locationId) {
        // Find available locker
        Locker locker = findAvailableLocker(package.getSize(), locationId);
        
        if (locker == null) {
            throw new NoAvailableLockerException("No lockers available");
        }
        
        // Reserve locker
        locker.setStatus(LockerStatus.RESERVED);
        locker.setReservedUntil(Instant.now().plus(15, ChronoUnit.MINUTES));
        lockerRepository.save(locker);
        
        return locker;
    }
    
    @Transactional
    public void deliverPackage(String deliveryCode, String lockerId) {
        // Validate delivery code
        Package package = packageRepository.findByDeliveryCode(deliveryCode)
            .orElseThrow(() -> new InvalidCodeException("Invalid delivery code"));
        
        if (package.getStatus() != PackageStatus.IN_TRANSIT) {
            throw new InvalidOperationException("Package already delivered");
        }
        
        // Get locker
        Locker locker = lockerRepository.findById(lockerId)
            .orElseThrow(() -> new LockerNotFoundException("Locker not found"));
        
        if (locker.getStatus() != LockerStatus.RESERVED) {
            throw new InvalidOperationException("Locker not reserved");
        }
        
        // Update locker
        locker.setStatus(LockerStatus.OCCUPIED);
        locker.setPackageId(package.getPackageId());
        locker.setReservedUntil(null);
        lockerRepository.save(locker);
        
        // Update package
        package.setStatus(PackageStatus.DELIVERED_TO_LOCKER);
        package.setLockerId(lockerId);
        package.setDeliveredAt(Instant.now());
        package.setExpiresAt(Instant.now().plus(3, ChronoUnit.DAYS));
        packageRepository.save(package);
        
        // Open locker (hardware call)
        openLockerDoor(lockerId);
        
        // Send notification
        notificationService.sendDeliveryNotification(package);
    }
    
    @Transactional
    public void pickupPackage(String pickupCode) {
        // Validate pickup code
        Package package = packageRepository.findByPickupCode(pickupCode)
            .orElseThrow(() -> new InvalidCodeException("Invalid pickup code"));
        
        if (package.getStatus() != PackageStatus.DELIVERED_TO_LOCKER) {
            throw new InvalidOperationException("Package not in locker");
        }
        
        if (package.getExpiresAt().isBefore(Instant.now())) {
            throw new PackageExpiredException("Package has expired");
        }
        
        // Get locker
        Locker locker = lockerRepository.findById(package.getLockerId())
            .orElseThrow(() -> new LockerNotFoundException("Locker not found"));
        
        // Update locker
        locker.setStatus(LockerStatus.AVAILABLE);
        locker.setPackageId(null);
        lockerRepository.save(locker);
        
        // Update package
        package.setStatus(PackageStatus.PICKED_UP);
        package.setPickedUpAt(Instant.now());
        packageRepository.save(package);
        
        // Open locker (hardware call)
        openLockerDoor(locker.getLockerId());
        
        // Send confirmation
        notificationService.sendPickupConfirmation(package);
    }
    
    private Locker findAvailableLocker(LockerSize packageSize, String locationId) {
        List<Locker> availableLockers = lockerRepository
            .findByLocationIdAndStatus(locationId, LockerStatus.AVAILABLE);
        
        return availableLockers.stream()
            .filter(locker -> isSizeCompatible(locker.getSize(), packageSize))
            .min(Comparator
                .comparing((Locker l) -> l.getSize() != packageSize)
                .thenComparing(Locker::getLockerNumber))
            .orElse(null);
    }
    
    private boolean isSizeCompatible(LockerSize lockerSize, LockerSize packageSize) {
        return lockerSize.ordinal() >= packageSize.ordinal();
    }
    
    private void openLockerDoor(String lockerId) {
        // Hardware integration - open physical locker
        lockerHardwareService.openDoor(lockerId);
    }
}
```

### 7.2 Code Generation

```java
@Service
public class CodeGenerationService {
    
    private static final int CODE_LENGTH = 6;
    private static final int MAX_RETRIES = 10;
    
    @Autowired
    private PackageRepository packageRepository;
    
    public String generateDeliveryCode() {
        return generateUniqueCode(code -> 
            packageRepository.existsByDeliveryCode(code));
    }
    
    public String generatePickupCode() {
        return generateUniqueCode(code -> 
            packageRepository.existsByPickupCode(code));
    }
    
    private String generateUniqueCode(Predicate<String> existsCheck) {
        for (int i = 0; i < MAX_RETRIES; i++) {
            String code = generateRandomCode();
            if (!existsCheck.test(code)) {
                return code;
            }
        }
        throw new CodeGenerationException("Failed to generate unique code");
    }
    
    private String generateRandomCode() {
        Random random = new Random();
        StringBuilder code = new StringBuilder();
        for (int i = 0; i < CODE_LENGTH; i++) {
            code.append(random.nextInt(10));
        }
        return code.toString();
    }
}
```

## 8. Concurrency Handling

### 8.1 Locker Reservation Lock

```
┌─────────────────────────────────────────────────────────┐
│         Concurrency Control                            │
└─────────────────────────────────────────────────────────┘

Problem: Multiple delivery persons trying to use same locker

Solution: Database-level locking

@Transactional
public Locker assignLocker(Package package, String locationId) {
    // Pessimistic lock on available lockers
    List<Locker> lockers = lockerRepository
        .findByLocationIdAndStatusWithLock(
            locationId, 
            LockerStatus.AVAILABLE
        );
    
    // Select and update atomically
    Locker locker = selectLocker(lockers, package.getSize());
    locker.setStatus(LockerStatus.RESERVED);
    lockerRepository.save(locker);
    
    return locker;
}
```

### 8.2 Optimistic Locking

```java
@Entity
public class Locker {
    @Id
    private String lockerId;
    
    @Version
    private Long version;  // Optimistic locking
    
    // ... other fields
}

// Update with version check
UPDATE lockers 
SET status = 'RESERVED', version = version + 1
WHERE locker_id = ? AND version = ? AND status = 'AVAILABLE'
```

## 9. Expiration Handling

### 9.1 Expired Package Cleanup

```
┌─────────────────────────────────────────────────────────┐
│         Expiration Handling                            │
└─────────────────────────────────────────────────────────┘

Scheduled Job (runs every hour):
1. Find packages expired > 3 days
2. Mark packages as EXPIRED
3. Free up lockers
4. Notify user (if not already notified)
5. Initiate return process
```

```java
@Scheduled(cron = "0 0 * * * *") // Every hour
public void handleExpiredPackages() {
    Instant expirationThreshold = Instant.now().minus(3, ChronoUnit.DAYS);
    
    List<Package> expiredPackages = packageRepository
        .findByStatusAndExpiresAtBefore(
            PackageStatus.DELIVERED_TO_LOCKER,
            expirationThreshold
        );
    
    for (Package package : expiredPackages) {
        // Free locker
        Locker locker = lockerRepository.findById(package.getLockerId())
            .orElse(null);
        if (locker != null) {
            locker.setStatus(LockerStatus.AVAILABLE);
            locker.setPackageId(null);
            lockerRepository.save(locker);
        }
        
        // Update package
        package.setStatus(PackageStatus.EXPIRED);
        packageRepository.save(package);
        
        // Notify user
        notificationService.sendExpirationNotification(package);
        
        // Initiate return
        returnService.initiateReturn(package);
    }
}
```

## 10. Notification System

### 10.1 Notification Flow

```
┌─────────────────────────────────────────────────────────┐
│         Notification System                            │
└─────────────────────────────────────────────────────────┘

Events:
├─ Package delivered → Send delivery notification
├─ Package ready for pickup → Send pickup reminder
├─ Package expiring soon (1 day left) → Send warning
├─ Package expired → Send expiration notice
└─ Package picked up → Send confirmation

Channels:
├─ Push notification (mobile app)
├─ SMS
├─ Email
└─ In-app notification
```

## 11. Location Search

### 11.1 Find Nearby Lockers

```java
@Service
public class LockerLocationService {
    
    public List<LockerLocation> findNearbyLockers(
            double latitude, 
            double longitude, 
            double radiusKm) {
        
        // Use geospatial query
        return lockerLocationRepository.findNearby(
            latitude, 
            longitude, 
            radiusKm
        );
    }
}
```

```sql
-- PostgreSQL with PostGIS
SELECT location_id, address, 
       ST_Distance(
           ST_MakePoint(longitude, latitude),
           ST_MakePoint(?, ?)
       ) AS distance
FROM locker_locations
WHERE ST_DWithin(
    ST_MakePoint(longitude, latitude),
    ST_MakePoint(?, ?),
    ?
)
ORDER BY distance
LIMIT 10;
```

## 12. Security Considerations

### 12.1 Code Security

```
┌─────────────────────────────────────────────────────────┐
│         Security Measures                              │
└─────────────────────────────────────────────────────────┘

1. Code Generation
   ├─ 6-digit random codes
   ├─ Cryptographically secure random
   └─ Unique codes (check database)

2. Code Validation
   ├─ Rate limiting (max 5 attempts)
   ├─ Code expiration (15 min for delivery)
   └─ One-time use codes

3. Access Control
   ├─ User authentication required
   ├─ Package ownership verification
   └─ Locker access logging

4. Data Protection
   ├─ Encrypt sensitive data
   ├─ Secure API endpoints (HTTPS)
   └─ Audit logs for all operations
```

## 13. Error Handling

### 13.1 Error Scenarios

```java
public class LockerException extends RuntimeException {
    // Base exception
}

public class NoAvailableLockerException extends LockerException {
    // No lockers available for package size
}

public class InvalidCodeException extends LockerException {
    // Invalid delivery/pickup code
}

public class PackageExpiredException extends LockerException {
    // Package expired, needs return
}

public class LockerNotFoundException extends LockerException {
    // Locker doesn't exist
}

public class InvalidOperationException extends LockerException {
    // Invalid operation (e.g., picking up already picked package)
}
```

## 14. Testing Considerations

### 14.1 Unit Tests

```java
@Test
public void testAssignLocker_Success() {
    // Given
    Package package = new Package(LockerSize.MEDIUM);
    String locationId = "loc-123";
    
    // When
    Locker locker = lockerService.assignLocker(package, locationId);
    
    // Then
    assertNotNull(locker);
    assertEquals(LockerStatus.RESERVED, locker.getStatus());
    assertTrue(isSizeCompatible(locker.getSize(), package.getSize()));
}

@Test
public void testAssignLocker_NoAvailable() {
    // Given - all lockers occupied
    // When/Then
    assertThrows(NoAvailableLockerException.class, () -> {
        lockerService.assignLocker(package, locationId);
    });
}
```

### 14.2 Integration Tests

- Test full delivery flow
- Test full pickup flow
- Test concurrent access
- Test expiration handling
- Test hardware integration

## Summary

**Key Design Decisions:**
1. **Three-tier locker sizes** (Small, Medium, Large) with size compatibility
2. **Dual code system** (delivery code for delivery person, pickup code for user)
3. **Reservation system** (15-minute window for delivery)
4. **Expiration handling** (3-day pickup window, automated cleanup)
5. **Geospatial search** for finding nearby lockers
6. **Optimistic locking** for concurrent access control
7. **Notification system** for all state changes
8. **Hardware integration** for physical locker control

**Trade-offs:**
- **Consistency vs Availability**: Strong consistency for locker assignments
- **Storage vs Performance**: Cache locker availability for faster lookups
- **Security vs Usability**: 6-digit codes balance security and usability

This design provides a robust, scalable system for managing package deliveries and pickups through automated lockers while ensuring security, reliability, and good user experience.
