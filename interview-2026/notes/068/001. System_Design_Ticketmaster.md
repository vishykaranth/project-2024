# System Design: Ticketmaster - In-Depth Summary

## 1. Requirements Gathering

### Functional Requirements
- Users can search for events
- Users can view event details
- Users can purchase tickets
- Users can view their ticket history
- Sellers can create events and list tickets
- Handle high concurrency during ticket sales

### Non-Functional Requirements
- High availability (99.9%)
- Low latency (< 200ms for search)
- Scalability (millions of users)
- Consistency (prevent overselling)
- Durability (don't lose transactions)

### Capacity Estimation
- 100M users, 10M daily active
- 1M events, 10K new events/day
- 10M tickets sold/day
- Peak: 100K requests/sec during popular sales

## 2. High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│              High-Level Architecture                     │
└─────────────────────────────────────────────────────────┘

                    [Users]
                       │
                       ▼
              ┌────────────────┐
              │  CDN / Load    │
              │    Balancer    │
              └────────┬───────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
        ▼              ▼              ▼
   [Web Servers]  [API Gateway]  [Mobile API]
        │              │              │
        └──────────────┼──────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
        ▼              ▼              ▼
   [Event Service] [Ticket Service] [User Service]
        │              │              │
        └──────────────┼──────────────┘
                       │
              ┌────────┴────────┐
              │                 │
              ▼                 ▼
        [Database]      [Cache Layer]
              │                 │
              └────────┬────────┘
                       │
              ┌────────┴────────┐
              │                 │
              ▼                 ▼
        [Message Queue]   [Search Service]
```

## 3. Core Components

### 3.1 Event Service
```
┌─────────────────────────────────────────────────────────┐
│              Event Service Architecture                  │
└─────────────────────────────────────────────────────────┘

[Event Service]
    │
    ├─► Event Management
    │   ├─ Create event
    │   ├─ Update event
    │   └─ Delete event
    │
    ├─► Event Search
    │   ├─ Search by location
    │   ├─ Search by date
    │   └─ Search by category
    │
    └─► Event Details
        ├─ Event info
        ├─ Venue details
        └─ Pricing tiers
```

### 3.2 Ticket Service (Critical Component)
```
┌─────────────────────────────────────────────────────────┐
│              Ticket Service Architecture                │
└─────────────────────────────────────────────────────────┘

[Ticket Service]
    │
    ├─► Ticket Inventory
    │   ├─ Available tickets
    │   ├─ Reserved tickets
    │   └─ Sold tickets
    │
    ├─► Ticket Reservation
    │   ├─ Lock tickets (15 min)
    │   ├─ Reserve for user
    │   └─ Release if expired
    │
    ├─► Ticket Purchase
    │   ├─ Validate reservation
    │   ├─ Process payment
    │   └─ Confirm purchase
    │
    └─► Ticket Management
        ├─ View tickets
        ├─ Transfer tickets
        └─ Cancel tickets
```

## 4. Database Design

### 4.1 Database Schema

```
┌─────────────────────────────────────────────────────────┐
│              Database Schema                            │
└─────────────────────────────────────────────────────────┘

Users Table:
├─ user_id (PK)
├─ email
├─ name
├─ phone
└─ created_at

Events Table:
├─ event_id (PK)
├─ name
├─ venue_id (FK)
├─ date_time
├─ category
└─ status

Venues Table:
├─ venue_id (PK)
├─ name
├─ address
├─ capacity
└─ location

Tickets Table:
├─ ticket_id (PK)
├─ event_id (FK)
├─ section
├─ row
├─ seat_number
├─ price
├─ status (available/reserved/sold)
├─ user_id (FK, nullable)
└─ reserved_until (nullable)

Reservations Table:
├─ reservation_id (PK)
├─ ticket_id (FK)
├─ user_id (FK)
├─ reserved_at
├─ expires_at
└─ status

Orders Table:
├─ order_id (PK)
├─ user_id (FK)
├─ total_amount
├─ status
├─ created_at
└─ payment_id

Order_Items Table:
├─ order_item_id (PK)
├─ order_id (FK)
├─ ticket_id (FK)
└─ price
```

### 4.2 Database Sharding Strategy

```
┌─────────────────────────────────────────────────────────┐
│              Database Sharding                          │
└─────────────────────────────────────────────────────────┘

Shard by event_id:
├─ Shard 1: event_id % 4 == 0
├─ Shard 2: event_id % 4 == 1
├─ Shard 3: event_id % 4 == 2
└─ Shard 4: event_id % 4 == 3

Benefits:
├─ Distribute load
├─ Scale independently
└─ Isolate failures
```

## 5. Ticket Purchase Flow

### 5.1 Purchase Sequence Diagram

```
┌─────────────────────────────────────────────────────────┐
│         Ticket Purchase Flow                            │
└─────────────────────────────────────────────────────────┘

User          Web Server    Ticket Service    Database    Payment Service
  │                │              │              │              │
  │──Search───────>│              │              │              │
  │<--Events-------│              │              │              │
  │                │              │              │              │
  │──Select───────>│              │              │              │
  │                │              │              │              │
  │                │──Reserve────>│              │              │
  │                │              │──Lock───────>│              │
  │                │              │<--Success----│              │
  │                │<--Reserved---│              │              │
  │<--Reserved------│              │              │              │
  │                │              │              │              │
  │──Checkout─────>│              │              │              │
  │                │──Purchase───>│              │              │
  │                │              │──Validate───>│              │
  │                │              │<--Valid------│              │
  │                │              │              │              │
  │                │              │──Charge─────────────────────>│
  │                │              │              │<--Success----│
  │                │              │              │              │
  │                │              │──Confirm────>│              │
  │                │              │<--Success----│              │
  │                │<--Success----│              │              │
  │<--Confirmed-----│              │              │              │
```

### 5.2 Ticket Reservation Mechanism

```
┌─────────────────────────────────────────────────────────┐
│         Ticket Reservation Flow                        │
└─────────────────────────────────────────────────────────┘

1. User selects tickets
   │
   ▼
2. Ticket Service checks availability
   │
   ├─► Available → Proceed
   └─► Not Available → Return error
   │
   ▼
3. Lock tickets in database
   ├─► UPDATE tickets SET status='reserved', 
   │   reserved_until=NOW()+15min
   │   WHERE ticket_id IN (...) AND status='available'
   │
   └─► Check affected rows
       ├─► All locked → Success
       └─► Some failed → Retry or fail
   │
   ▼
4. Create reservation record
   │
   ▼
5. Return reservation ID to user
   │
   ▼
6. User has 15 minutes to complete purchase
   │
   ├─► Purchase completed → Mark as sold
   └─► Timeout → Release tickets
```

## 6. Handling High Concurrency

### 6.1 Optimistic Locking

```
┌─────────────────────────────────────────────────────────┐
│         Optimistic Locking Strategy                    │
└─────────────────────────────────────────────────────────┘

Ticket Table:
├─ ticket_id
├─ version (increment on update)
├─ status
└─ ...

Update Query:
UPDATE tickets 
SET status='reserved', version=version+1
WHERE ticket_id=? AND version=? AND status='available'

If affected_rows == 0:
    → Ticket was modified by another transaction
    → Retry or fail
```

### 6.2 Distributed Locking (Redis)

```
┌─────────────────────────────────────────────────────────┐
│         Distributed Locking with Redis                 │
└─────────────────────────────────────────────────────────┘

1. User requests tickets
   │
   ▼
2. Acquire distributed lock
   ├─► SET ticket:123:lock "user_id" EX 15 NX
   │
   ├─► Success → Proceed with reservation
   └─► Failed → Another user is processing
   │
   ▼
3. Check availability in cache
   │
   ▼
4. Reserve in database
   │
   ▼
5. Update cache
   │
   ▼
6. Release lock after reservation
```

### 6.3 Queue-Based Approach

```
┌─────────────────────────────────────────────────────────┐
│         Queue-Based Ticket Purchase                    │
└─────────────────────────────────────────────────────────┘

[Users] → [Load Balancer] → [Web Servers]
                              │
                              ▼
                        [Message Queue]
                              │
                              ▼
                    [Ticket Processors]
                              │
                              ▼
                        [Database]
```

**Benefits:**
- Smooth traffic spikes
- Fair processing (FIFO)
- Better control over rate

## 7. Caching Strategy

### 7.1 Multi-Level Caching

```
┌─────────────────────────────────────────────────────────┐
│         Caching Architecture                           │
└─────────────────────────────────────────────────────────┘

Level 1: CDN
├─ Static content
├─ Event listings
└─ Images

Level 2: Application Cache (Redis)
├─ Event details
├─ Available ticket counts
└─ User sessions

Level 3: Database Query Cache
└─ Frequently accessed data
```

### 7.2 Cache Invalidation

```
┌─────────────────────────────────────────────────────────┐
│         Cache Invalidation Strategy                    │
└─────────────────────────────────────────────────────────┘

On Ticket Purchase:
1. Update database
2. Invalidate cache for event
3. Update available count cache
4. Publish event to message queue
5. Other servers invalidate their cache
```

## 8. Search Functionality

### 8.1 Search Architecture

```
┌─────────────────────────────────────────────────────────┐
│         Search Service Architecture                    │
└─────────────────────────────────────────────────────────┘

[Search Request]
    │
    ▼
[API Gateway]
    │
    ▼
[Search Service]
    │
    ├─► Elasticsearch
    │   ├─ Event names
    │   ├─ Venue names
    │   ├─ Locations
    │   └─ Categories
    │
    └─► Filters
        ├─ Date range
        ├─ Location
        ├─ Price range
        └─ Category
```

### 8.2 Search Index Structure

```json
{
  "event_id": "123",
  "name": "Concert",
  "venue": "Madison Square Garden",
  "location": {
    "city": "New York",
    "state": "NY",
    "coordinates": [40.7505, -73.9934]
  },
  "date": "2024-06-15T20:00:00Z",
  "category": "Music",
  "price_range": {
    "min": 50,
    "max": 500
  }
}
```

## 9. Scalability Solutions

### 9.1 Horizontal Scaling

```
┌─────────────────────────────────────────────────────────┐
│         Horizontal Scaling                             │
└─────────────────────────────────────────────────────────┘

Web Servers:
├─ Stateless design
├─ Load balancer distributes traffic
└─ Auto-scaling based on load

Database:
├─ Read replicas for reads
├─ Sharding for writes
└─ Connection pooling

Cache:
├─ Redis cluster
└─ Distributed caching
```

### 9.2 Read/Write Separation

```
┌─────────────────────────────────────────────────────────┐
│         Read/Write Separation                          │
└─────────────────────────────────────────────────────────┘

Writes:
User → Web Server → Master DB

Reads:
User → Web Server → Read Replica

Benefits:
├─ Distribute read load
├─ Scale reads independently
└─ Better performance
```

## 10. Reliability & Fault Tolerance

### 10.1 Circuit Breaker Pattern

```
┌─────────────────────────────────────────────────────────┐
│         Circuit Breaker                                │
└─────────────────────────────────────────────────────────┘

Payment Service:
├─ Normal: Requests pass through
├─ Failure threshold reached: Open circuit
├─ Fail fast: Return error immediately
└─ After timeout: Half-open, test one request
```

### 10.2 Retry Strategy

```
┌─────────────────────────────────────────────────────────┐
│         Retry Strategy                                 │
└─────────────────────────────────────────────────────────┘

Exponential Backoff:
├─ Attempt 1: Immediate
├─ Attempt 2: Wait 1s
├─ Attempt 3: Wait 2s
├─ Attempt 4: Wait 4s
└─ Max 3-5 retries
```

## 11. Monitoring & Observability

```
┌─────────────────────────────────────────────────────────┐
│         Monitoring Stack                               │
└─────────────────────────────────────────────────────────┘

Metrics:
├─ Request rate
├─ Error rate
├─ Latency (p50, p95, p99)
└─ Ticket sales rate

Logging:
├─ Centralized logging (ELK)
├─ Structured logs
└─ Correlation IDs

Tracing:
├─ Distributed tracing
├─ Request flow tracking
└─ Performance bottlenecks
```

## 12. Security Considerations

- **Authentication**: JWT tokens, OAuth
- **Authorization**: Role-based access control
- **Rate Limiting**: Prevent abuse
- **Payment Security**: PCI compliance, tokenization
- **Data Encryption**: TLS in transit, encryption at rest

## Summary

**Key Design Decisions:**
1. Database sharding by event_id for scalability
2. Two-phase reservation (lock then purchase) to prevent overselling
3. Distributed locking (Redis) for concurrency control
4. Multi-level caching (CDN, Redis, DB cache)
5. Queue-based processing for high-traffic events
6. Read replicas for scaling reads
7. Search service (Elasticsearch) for fast queries
8. Circuit breakers for fault tolerance

**Trade-offs:**
- **Consistency vs Availability**: Strong consistency for ticket inventory
- **Latency vs Consistency**: Acceptable latency for accurate inventory
- **Cost vs Performance**: Caching and CDN increase cost but improve performance

This design handles high concurrency, prevents overselling, and scales to millions of users while maintaining data consistency and system reliability.
